<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operator precedence parser · Daf.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Daf.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Daf</a></li><li><a class="tocitem" href="data.html">Data</a></li><li><a class="tocitem" href="read_only.html">Read-only</a></li><li><a class="tocitem" href="formats.html">Formats</a></li><li><a class="tocitem" href="memory_format.html">Memory Format</a></li><li><a class="tocitem" href="queries.html">Queries</a></li><li><a class="tocitem" href="registry.html">Operations registry</a></li><li><a class="tocitem" href="operations.html">Query operations</a></li><li><a class="tocitem" href="storage_types.html">Storage types</a></li><li><a class="tocitem" href="matrix_layouts.html">Matrix layouts</a></li><li class="is-active"><a class="tocitem" href="oprec.html">Operator precedence parser</a><ul class="internal"><li><a class="tocitem" href="#Escaping-special-characters"><span>Escaping special characters</span></a></li><li><a class="tocitem" href="#Encoding-/-decoding"><span>Encoding / decoding</span></a></li><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Expression-tree"><span>Expression tree</span></a></li><li><a class="tocitem" href="#Context-and-errors"><span>Context and errors</span></a></li><li><a class="tocitem" href="#Parsing-trees"><span>Parsing trees</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="messages.html">Messages</a></li><li><a class="tocitem" href="example_data.html">Example data</a></li><li><a class="tocitem" href="todo.html">TODO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="oprec.html">Operator precedence parser</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="oprec.html">Operator precedence parser</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.md?plain=1#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Operator-precedence-parser"><a class="docs-heading-anchor" href="#Operator-precedence-parser">Operator precedence parser</a><a id="Operator-precedence-parser-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-precedence-parser" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec" href="#Daf.Oprec"><code>Daf.Oprec</code></a> — <span class="docstring-category">Module</span></header><section><div><p>You can safely skip this module if you are only using <code>Daf</code>. It is an internal module which is only of interest for maintainers. Some of the types here are also used when implementing additional query element-wise or reduction operations. In particular, this isn&#39;t reexported by default when <code>using Daf</code>.</p><p>Ideally <code>Daf</code> should have used some established parser generator module for parsing queries, making this unnecessary. However, As of writing this code, Julia doesn&#39;t seem to have such a parser generator solution. Therefore, this module provides a simple operator precedence based parser generator. The upside is that we can tailor this to our needs (in particular, provide tailored error messages when parsing fails).</p><p>Operator-precedence based parsers are simple to define and implement. A set of <code>Regex</code> patterns are used for converting the input string into <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>s. Some tokens are <a href="oprec.html#Daf.Oprec.Operator"><code>Operator</code></a>s, which have <a href="oprec.html#Daf.Oprec.Associativity"><code>Associativity</code></a> and precedence. We therefore build an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> tree from the tokens, and then &quot;parse&quot; it into something more convenient to work with.</p><p>This is pretty intuitive when thinking about something like arithmetic expressions <code>1 + 2 * 3</code>. However, it turns out that this approach allows for parsing a wide range of languages, including languages which one wouldn&#39;t immediately think of as &quot;expressions&quot;, all the way up to full programming languages.</p><p>That said, the implementation here is tailored for parsing <code>Daf</code> queries, and is not general enough to be a package on its own.</p><p>Specifically, we assume that <code>_[0-9A-F][0-9A-F]</code> can&#39;t appear inside an operator, which is mostly reasonable; that <code>\x</code> is used to escape &quot;special&quot; characters to allow them in &quot;normal&quot; tokens, which isn&#39;t typically true in most languages; we don&#39;t support postfix operators (e.g., <code>;</code> in C), we assume all operators are infix (e.g., <code>*</code> in arithmetic), but some can also be prefix (e.g., <code>-</code> in arithmetic); there&#39;s no support for parenthesis; and we assume the parsed expressions are &quot;small&quot; (can be squashed into a single line) for the purpose of creating friendly error messages.</p><p>We only reexport <a href="oprec.html#Daf.Oprec.escape_query"><code>escape_query</code></a>, <a href="oprec.html#Daf.Oprec.unescape_query"><code>unescape_query</code></a> and <a href="oprec.html#Daf.Oprec.is_safe_query_char"><code>is_safe_query_char</code></a> from the top-level <code>Daf</code> module itself, as these are all you might be interested in from outside the <code>Daf</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL1-L31">source</a></section></article><h2 id="Escaping-special-characters"><a class="docs-heading-anchor" href="#Escaping-special-characters">Escaping special characters</a><a id="Escaping-special-characters-1"></a><a class="docs-heading-anchor-permalink" href="#Escaping-special-characters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.escape_query" href="#Daf.Oprec.escape_query"><code>Daf.Oprec.escape_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escape_query(token::AbstractString)::String</code></pre><p>Given some raw <code>token</code> (name of an axis, axis entry or property, or a parameter value), which may contain special characters, return an escaped version to be used in a query string.</p><p>We need to consider the following kinds of characters:</p><ul><li><p><strong>Safe</strong> (<a href="oprec.html#Daf.Oprec.is_safe_query_char"><code>is_safe_query_char</code></a>) characters include <code>a</code> - <code>z</code>, <code>A</code> - <code>Z</code>, <code>0</code> - <code>9</code>, <code>_</code>, <code>+</code>, <code>-</code>, and <code>.</code>, as well as any non-ASCII (that is, Unicode) characters. Any sequence of these characters will be considered a single token, used to write names (of axes, axis entries, properties, operations, parameters), and also values (for parameters). These cover all the common cases (including signed integer and floating point values).</p></li><li><p>All other ASCII characters are (at least potentially) <strong>special</strong>, that is, may be used to describe the query structure. Currently only a subset of these are actually used: <code>#</code>, <code>\</code>, <code>@</code>, <code>:</code>, <code>&lt;</code>, <code>=</code>, <code>,</code>, <code>;</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> and <code>%</code>, and, of course, white space (spaces, tabs and line breaks) which can be used for readability. Additional characters may be used in future version, if we choose to enhance the query language.</p></li><li><p>Prefixing <em>any</em> character with a <code>\</code> allows using it inside a token. This is useful if some name or value contains a special character. For example, if you have a cell whose name is <code>ACTG:Plate1</code>, and you want to access the name of the batch of this specific cell, you will have to write <code>cell = ACTG\:Plate1 : batch</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>\</code> character is also used by Julia inside <code>&quot;...&quot;</code> string literals, to escape writing non-printable characters. For example, <code>&quot;\n&quot;</code> is a single-character string containing a line break, and therefore <code>&quot;\\&quot;</code> is used to write a single <code>\</code>. Thus the above example would have to be written as <code>&quot;cell = ACTG\\:Plate1 : batch&quot;</code>. This isn&#39;t nice.</p><p>Luckily, Julia also has <code>raw&quot;...&quot;</code> string literals that work similarly to Python&#39;s <code>r&quot;...&quot;</code> strings (in Julia, <code>r&quot;...&quot;</code> is a regular expression, not a string). Inside raw string literals, a <code>\</code> is a <code>\</code> (unless it precedes a <code>&quot;</code>). Therefore the above example could also be written as <code>raw&quot;cell = ACTG\:Plate1 : batch</code>, which is more readable.</p></div></div><p>Back to <code>escape_query</code> - it will prefix any (potentially) special character with a <code>\</code>. It is useful if you want to inject a data into a query. Often this happens when using <code>$(...)</code> to embed values into a query string, e.g., the query <code>$(axis) @ $(property) &gt; $(value)</code> is unsafe, as any of the embedded variables may contain unsafe characters. You should instead write something like <code>$(escape_query(axis)) @ $(escape_query(property)) &gt; $(escape_query(value))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL60-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.unescape_query" href="#Daf.Oprec.unescape_query"><code>Daf.Oprec.unescape_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unescape_query(escaped_token::AbstractString)::String</code></pre><p>Undo <a href="oprec.html#Daf.Oprec.escape_query"><code>escape_query</code></a>, that is, given a query token with a <code>\</code> characters escaping special characters, drop the <code>\</code> to get back the original string value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.is_safe_query_char" href="#Daf.Oprec.is_safe_query_char"><code>Daf.Oprec.is_safe_query_char</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_safe_query_char(character::Char)::Bool</code></pre><p>Return whether a character is safe to use inside a query token (name of an axis, axis entry or property, or a parameter value).</p><p>The safe characters are <code>a</code> - <code>z</code>, <code>A</code> - <code>Z</code>, <code>0</code> - <code>9</code>, <code>_</code>, <code>+</code>, <code>-</code>, and <code>.</code>, as well as any non-ASCII (that is, Unicode) characters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL111-L119">source</a></section></article><h2 id="Encoding-/-decoding"><a class="docs-heading-anchor" href="#Encoding-/-decoding">Encoding / decoding</a><a id="Encoding-/-decoding-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-/-decoding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.encode_expression" href="#Daf.Oprec.encode_expression"><code>Daf.Oprec.encode_expression</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given an expression string to parse, encode any character escaped by a <code>\</code> such that it will be considered a normal <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a> character. Every escaped character is replaced by <code>_XX</code> using URI encoding, but replacing the <code>%</code> with a <code>_</code> so we can deal with unescaped <code>%</code> as an operator, so we also need to encode <code>_</code> as <code>_5F</code>, so we need to encode <code>\_</code> as <code>_5C_5F</code>. Isn&#39;t encoding <em>fun</em>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.decode_expression" href="#Daf.Oprec.decode_expression"><code>Daf.Oprec.decode_expression</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given the results of <a href="oprec.html#Daf.Oprec.encode_expression"><code>encode_expression</code></a>, decode it back to its original form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL145-L147">source</a></section></article><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Syntax" href="#Daf.Oprec.Syntax"><code>Daf.Oprec.Syntax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Syntax{E}
    space_regex::Regex
    operand_regex::Regex
    operator_regex::Regex
    operators::Dict{String, Operator{E}}
end</code></pre><p>Describe the syntax to parse using the patterns for tokens.</p><p>When tokenizing, we try matching the <code>space_regex</code> first. Anything that matches is considered to be white space and discarded. We then try to match the <code>operand_regex</code>. Anything that matches is considered to be an operand <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>. Otherwise, we try to match the <code>operator_regex</code>, and look up the result in the <code>operators</code> dictionary to obtain an <a href="oprec.html#Daf.Oprec.Operator"><code>Operator</code></a> <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>. Anything that doesn&#39;t match (or that doesn&#39;t exist in the <code>operators</code>) is reported as an invalid character.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL253-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Operator" href="#Daf.Oprec.Operator"><code>Daf.Oprec.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Operator{E}
    id::E
    is_prefix::Bool
    associativity::Associativity
    precedence::Int
end</code></pre><p>Describe an operator token.</p><p>We attach an arbitrary <code>id</code> to the operators, which is typically used to carry some <code>@enum</code> to identify it for parsing the expression tree.</p><p>The implementation is restricted to operators which are always infix (e.g., <code>+</code> in arithmetic expressions). Some operators can also be <code>is_prefix</code> (e.g., <code>-</code> in arithmetic expressions).</p><p>Higher <code>precedence</code> operators (e.g., <code>*</code> in arithmetic expressions) will bind more strongly than lower precedence operators (e.g., <code>+</code> in arithmetic expressions). That is, <code>a + b * c</code> will be parsed as <code>a + (b * c)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL166-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Associativity" href="#Daf.Oprec.Associativity"><code>Daf.Oprec.Associativity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For infix operators, how to group a sequence of operators.</p><p><code>LeftAssociative</code> - groups <code>1 + 2 + 3</code> as <code>(1 + 2) + 3</code>. Parsing these operators is marginally faster.</p><p><code>RightAssociative</code> - groups <code>1 + 2 + 3</code> as <code>1 + (2 + 3)</code>. The current implementation requires this for parsing lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL157-L163">source</a></section></article><h2 id="Expression-tree"><a class="docs-heading-anchor" href="#Expression-tree">Expression tree</a><a id="Expression-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-tree" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Token" href="#Daf.Oprec.Token"><code>Daf.Oprec.Token</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Token{E}
    first_index::Int
    last_index::Int
    string::String
    operator::Union{Operator{E}, Nothing}
end</code></pre><p>A parsed token of the expression (leaf node in an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> tree).</p><p>This contains the location (<code>first_index</code> .. <code>last_index</code>) in the (encoded) expression string to enable generating friendly error messages. There are no line numbers in locations because in <code>Daf</code> we squash our queries to a single-line, under the assumption they are &quot;relatively simple&quot;. This allows us to simplify the code.</p><p>We also hold the (decoded!) <code>string</code> of the token. If the token is an <a href="oprec.html#Daf.Oprec.Operator"><code>Operator</code></a>, we also provide its description.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL192-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Operation" href="#Daf.Oprec.Operation"><code>Daf.Oprec.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Operation{E}
    left::Union{Operation{E}, Token{E}, Nothing}
    token::Token{E}
    right::Union{Operation{E}, Token{E}}
end</code></pre><p>An operation (node in an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> tree).</p><p>The <code>token</code> describes the <a href="oprec.html#Daf.Oprec.Operator"><code>Operator</code></a>. There&#39;s always a <code>right</code> sub-tree, but for prefix operators, the <code>left</code> sub-tree is <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL216-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Expression" href="#Daf.Oprec.Expression"><code>Daf.Oprec.Expression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Expression{E} = Union{Operation{E}, Token{E}}</code></pre><p>An expression tree - either an <a href="oprec.html#Daf.Oprec.Operation"><code>Operation</code></a> or an operand (<a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.build_encoded_expression" href="#Daf.Oprec.build_encoded_expression"><code>Daf.Oprec.build_encoded_expression</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_encoded_expression(
    encoded_string::AbstractString,
    syntax::Syntax{E},
)::Union{Expression{E}, Nothing} where {E}</code></pre><p>Build an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> tree from an <code>encoded_string</code> (that went through <a href="oprec.html#Daf.Oprec.encode_expression"><code>encode_expression</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL478-L485">source</a></section></article><h2 id="Context-and-errors"><a class="docs-heading-anchor" href="#Context-and-errors">Context and errors</a><a id="Context-and-errors-1"></a><a class="docs-heading-anchor-permalink" href="#Context-and-errors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.Context" href="#Daf.Oprec.Context"><code>Daf.Oprec.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Context(encoded_string::AbstractString)</code></pre><p>A context for parsing a sub <code>Expression</code>.</p><p>When processing an <code>Expression</code> tree, we go top-down, collecting context entries along the way. This way, when we discover some invalid construct, we can show this in an error message, helping the user understand how the expression was parsed, and why it is invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL504-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.error_in_context" href="#Daf.Oprec.error_in_context"><code>Daf.Oprec.error_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">error_in_context(context::Context{E}, message::AbstractString)::Nothing where {E}</code></pre><p>Report a parsing error in some <a href="oprec.html#Daf.Oprec.Context"><code>Context</code></a>.</p><p>This provides location markers for the nested <a href="oprec.html#Daf.Oprec.Context"><code>Context</code></a> that led us to the point where the error occurred. It only works for small (one-line) inputs, where there&#39;s little or no recursion in the parsing. Therefore, it is a good fit for <code>Daf</code> queries, but not for a more general parsed languages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL522-L530">source</a></section></article><h2 id="Parsing-trees"><a class="docs-heading-anchor" href="#Parsing-trees">Parsing trees</a><a id="Parsing-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_in_context" href="#Daf.Oprec.parse_in_context"><code>Daf.Oprec.parse_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_in_context(
    parse::Union{Function, Type},
    context::Context{E},
    expression::Expression{E};
    name::AbstractString,
    operators::Vector{E} = E[],
)::Any where {E}</code></pre><p>Parse a node of an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a>, using it as the <a href="oprec.html#Daf.Oprec.Context"><code>Context</code></a> when parsing any sub-expression. That is, push the top-level <code>expression</code> into the context, invoke the <code>parse()</code> function, and pop the <code>expression</code> from the context. Will return the results of the <code>parse</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL551-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_string_in_context" href="#Daf.Oprec.parse_string_in_context"><code>Daf.Oprec.parse_string_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_string_in_context(
    context::Context{E},
    expression::Expression{E};
    name::AbstractString,
)::AbstractString where {E}</code></pre><p>If the <code>expression</code> is not an operand [<code>Token</code>], report an <a href="oprec.html#Daf.Oprec.error_in_context"><code>error_in_context</code></a>, using the <code>name</code>.</p><p>Otherwise, return the string of the operand <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL700-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_operand_in_context" href="#Daf.Oprec.parse_operand_in_context"><code>Daf.Oprec.parse_operand_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_operand_in_context(
    parse::Union{Function, Type},
    context::Context{E},
    expression::Expression{E};
    name::AbstractString,
)::Any where {E}</code></pre><p>Parse an operand in an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> in some <a href="oprec.html#Daf.Oprec.Context"><code>Context</code></a>.</p><p>If the <code>expression</code> is not an operand [<code>Token</code>], report an <a href="oprec.html#Daf.Oprec.error_in_context"><code>error_in_context</code></a>, using the <code>name</code>.</p><p>Otherwise, give the <code>parse</code> function the operand <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>, and returns whatever the result it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL671-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_operation_in_context" href="#Daf.Oprec.parse_operation_in_context"><code>Daf.Oprec.parse_operation_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_operation_in_context(
    parse::Union{Function, Type},
    context::Context{E},
    expression::Expression{E};
    expression_name::AbstractString,
    operator_name::AbstractString,
    operators::Vector{E},
)::Any where {E}</code></pre><p>Parse an operation in an <a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a>.</p><p>If the <code>expression</code> is not an <a href="oprec.html#Daf.Oprec.Operation"><code>Operation</code></a> using one of the listed <code>operators</code>, report an <a href="oprec.html#Daf.Oprec.error_in_context"><code>error_in_context</code></a> using the <code>expression_name</code> and the <code>operator_name</code>.</p><p>Otherwise, give the <code>parse</code> function the left sub-<a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a> (or <code>nothing</code> for a prefix operator), the <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a> of the operator, and the right sub-<a href="oprec.html#Daf.Oprec.Expression"><code>Expression</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL742-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_list_in_context" href="#Daf.Oprec.parse_list_in_context"><code>Daf.Oprec.parse_list_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_list_in_context(
    [parse_element::Union{Function, Type},]
    context::Context{E},
    expression::Expression{E};
    list_name::AbstractString,
    element_type::Type{T},
    first_operator::Union{Token{E}, Nothing} = nothing,
    operators::Vector{E},
)::Vector{T} where {T, E}</code></pre><p>This converts an expression of the form <code>element ( operator element )*</code> into a vector of <code>element</code>, assuming the <code>operators</code> have right <a href="oprec.html#Daf.Oprec.Associativity"><code>Associativity</code></a>. For example, <code>property_name : property_name : ...</code> for a chained property lookup.</p><p>We repeatedly invoke the <code>parse_element</code> function (or the <code>element_type</code> constructor, if <code>parse_element</code> is not given), with the <code>context</code> (using the <code>list_name</code>), the operator immediately to the left of each sub-<code>expression</code> (using the <code>first_operator</code> for the 1st one), and the sub-expression. We collect the results into a <code>Vector</code> of the <code>element_type</code>.</p><p>This always matches. If the <code>expression</code> isn&#39;t an <a href="oprec.html#Daf.Oprec.Operation"><code>Operation</code></a> using one of the <code>operators</code>, then this simply returns a single-element vector. That said, naturally parsing the field may fail.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL785-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.parse_with_list_in_context" href="#Daf.Oprec.parse_with_list_in_context"><code>Daf.Oprec.parse_with_list_in_context</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_with_list_in_context(
    parse::Union{Function, Type},
    context::Context{E},
    expression::Expression{E};
    expression_name::AbstractString,
    separator_name::AbstractString,
    separator_operators::Vector{E},
    list_name::AbstractString,
    parse_element::Union{Function, Type, Nothing} = nothing,
    element_type::Type{L},
    first_operator::Bool = false,
    operators::Vector{E},
)::Any where {L, E}</code></pre><p>This converts an expression of the form <code>something separator element ( operator element )*</code> into a combined object, which typically has two members, a field for <code>something</code> and a vector for one or more <code>element</code>. For example, <code>operation ; parameter_assignment , parameter_assignment , ...</code> for invoking an element-wise or reduction operation.</p><p>If the <code>expression</code> isn&#39;t an <a href="oprec.html#Daf.Oprec.Operation"><code>Operation</code></a> using one of the <code>separator_operators</code>, then we assume there is no list of <code>elements</code>. Otherwise this invokes <a href="oprec.html#Daf.Oprec.parse_list_in_context"><code>parse_list_in_context</code></a> for collecting the elements. If <code>first_operator</code>, we give it the separator operator as the first operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL850-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Oprec.check_operation" href="#Daf.Oprec.check_operation"><code>Daf.Oprec.check_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_operation(
    expression::Expression{E},
    operators::Vector{E}
)::Union{Token{E}, Nothing} where {E}</code></pre><p>Check whether an <code>expression</code> is an <a href="oprec.html#Daf.Oprec.Operation"><code>Operation</code></a> using one of the specified <code>operators</code>. If so, return the operator&#39;s <a href="oprec.html#Daf.Oprec.Token"><code>Token</code></a>; otherwise, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/oprec.jl?plain=1#LL719-L727">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="oprec.html#Daf.Oprec"><code>Daf.Oprec</code></a></li><li><a href="oprec.html#Daf.Oprec.Associativity"><code>Daf.Oprec.Associativity</code></a></li><li><a href="oprec.html#Daf.Oprec.Context"><code>Daf.Oprec.Context</code></a></li><li><a href="oprec.html#Daf.Oprec.Expression"><code>Daf.Oprec.Expression</code></a></li><li><a href="oprec.html#Daf.Oprec.Operation"><code>Daf.Oprec.Operation</code></a></li><li><a href="oprec.html#Daf.Oprec.Operator"><code>Daf.Oprec.Operator</code></a></li><li><a href="oprec.html#Daf.Oprec.Syntax"><code>Daf.Oprec.Syntax</code></a></li><li><a href="oprec.html#Daf.Oprec.Token"><code>Daf.Oprec.Token</code></a></li><li><a href="oprec.html#Daf.Oprec.build_encoded_expression"><code>Daf.Oprec.build_encoded_expression</code></a></li><li><a href="oprec.html#Daf.Oprec.check_operation"><code>Daf.Oprec.check_operation</code></a></li><li><a href="oprec.html#Daf.Oprec.decode_expression"><code>Daf.Oprec.decode_expression</code></a></li><li><a href="oprec.html#Daf.Oprec.encode_expression"><code>Daf.Oprec.encode_expression</code></a></li><li><a href="oprec.html#Daf.Oprec.error_in_context"><code>Daf.Oprec.error_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.escape_query"><code>Daf.Oprec.escape_query</code></a></li><li><a href="oprec.html#Daf.Oprec.is_safe_query_char"><code>Daf.Oprec.is_safe_query_char</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_in_context"><code>Daf.Oprec.parse_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_list_in_context"><code>Daf.Oprec.parse_list_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_operand_in_context"><code>Daf.Oprec.parse_operand_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_operation_in_context"><code>Daf.Oprec.parse_operation_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_string_in_context"><code>Daf.Oprec.parse_string_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.parse_with_list_in_context"><code>Daf.Oprec.parse_with_list_in_context</code></a></li><li><a href="oprec.html#Daf.Oprec.unescape_query"><code>Daf.Oprec.unescape_query</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="matrix_layouts.html">« Matrix layouts</a><a class="docs-footer-nextpage" href="messages.html">Messages »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 3 August 2023 16:11">Thursday 3 August 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
