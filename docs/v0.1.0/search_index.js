var documenterSearchIndex = {"docs":
[{"location":"storage_types.html#Storage-types","page":"Storage types","title":"Storage types","text":"","category":"section"},{"location":"storage_types.html","page":"Storage types","title":"Storage types","text":"Daf.StorageTypes","category":"page"},{"location":"storage_types.html#Daf.StorageTypes","page":"Storage types","title":"Daf.StorageTypes","text":"Only a restricted set of scalar, matrix and vector types is stored by Daf.\n\nThe set of scalar types is restricted because we need to be able to store them in disk files. This rules out compound types such as Dict. This isn't an issue for vector and matrix elements but is sometimes bothersome for \"scalar\" data (not associated with any axis). If you find yourself needed to store such data, you'll have to serialize it to a string. By convention, we use JSON blobs for such data to maximize portability between different systems.\n\nJulia supports a potentially infinite variety of ways to represent matrices and vectors. Daf is intentionally restricted to specific representations. This has several advantages:\n\nDaf storage formats need only implement storing these restricted representations, which lend themselves to simple storage in consecutive bytes (in memory and/or on disk). These representations also allow for memory-mapping the data from disk files, which allows Daf to deal with data sets larger than the available memory.\nClient code need only worry about dealing with these restricted representations, which limits the amount of code paths required for efficient algorithm implementations. However, you (mostly) need not worry about this when invoking library functions, which have code paths covering all common matrix types. You do need to consider the layout of the data, though (see below).\n\nThis has the downside that Daf doesn't support efficient storage of specialized matrices (to pick a random example, upper triangular matrices). This isn't a great loss, since Daf targets storing arbitrary scientific data (especially biological data), which in general is not of any such special shape. The upside is that all matrices stored and returned by Daf have a clear MatrixLayouts (regardless of whether they are dense or sparse). This allows user code to ensure it is working \"with the grain\" of the data, which is much more efficient.\n\n\n\n\n\n","category":"module"},{"location":"storage_types.html#Storable-types","page":"Storage types","title":"Storable types","text":"","category":"section"},{"location":"storage_types.html","page":"Storage types","title":"Storage types","text":"Daf.StorageTypes.StorageScalar\nDaf.StorageTypes.StorageVector\nDaf.StorageTypes.StorageMatrix","category":"page"},{"location":"storage_types.html#Daf.StorageTypes.StorageScalar","page":"Storage types","title":"Daf.StorageTypes.StorageScalar","text":"StorageScalar = Union{\n    String,\n    Bool,\n    Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64,\n    Float32, Float64\n}\n\nTypes that can be used as scalars, or elements in stored matrices or vectors.\n\nThis is restricted to numbers (including Booleans) and strings. It is arguably too restrictive, as in principle we could support any arbitrary isbitstype. However, in practice this would cause much trouble when accessing the data from other systems (specifically Python and R). Since Daf targets storing scientific data (especially biological data), as opposed to \"anything at all\", this restriction seems reasonable.\n\n\n\n\n\n","category":"type"},{"location":"storage_types.html#Daf.StorageTypes.StorageVector","page":"Storage types","title":"Daf.StorageTypes.StorageVector","text":"StorageVector{T} = AbstractVector{T} where {T <: StorageScalar}\n\nVectors that can be directly stored (and fetched) from Daf storage.\n\nThe element type must be a StorageScalar, to allow storing the data in disk files.\n\n\n\n\n\n","category":"type"},{"location":"storage_types.html#Daf.StorageTypes.StorageMatrix","page":"Storage types","title":"Daf.StorageTypes.StorageMatrix","text":"StorageMatrix{T} = AbstractMatrix{T} where {T <: StorageScalar}\n\nMatrices that can be directly stored (and fetched) from Daf storage.\n\nThe element type must be a StorageScalar, to allow storing the data in disk files.\n\nnote: Note\nAll matrices we store must have a clear MatrixLayouts, that is, must be in either row- or column-major format.\n\n\n\n\n\n","category":"type"},{"location":"storage_types.html#Mappable-types","page":"Storage types","title":"Mappable types","text":"","category":"section"},{"location":"storage_types.html","page":"Storage types","title":"Storage types","text":"Daf.StorageTypes.MappableVector\nDaf.StorageTypes.MappableMatrix","category":"page"},{"location":"storage_types.html#Daf.StorageTypes.MappableVector","page":"Storage types","title":"Daf.StorageTypes.MappableVector","text":"MappableVector{T} = Union{DenseVector{T}, SparseVector{T}} where {T <: StorageScalar}\n\nvectors that we can memory-map to disk storage. Storing any other vector type into disk storage will convert the data to one of these formats.\n\nThe element type must be a StorageScalar.\n\n\n\n\n\n","category":"type"},{"location":"storage_types.html#Daf.StorageTypes.MappableMatrix","page":"Storage types","title":"Daf.StorageTypes.MappableMatrix","text":"MappableMatrix{T} = Union{DenseMatrix{T}, SparseMatrixCSC{T}} where {T <: StorageScalar}\n\nMatrices that we can memory-map to disk storage. Storing any other matrix type into disk storage will convert the data to one of these formats.\n\nThe element type must be a StorageScalar.\n\n\n\n\n\n","category":"type"},{"location":"storage_types.html#Index","page":"Storage types","title":"Index","text":"","category":"section"},{"location":"storage_types.html","page":"Storage types","title":"Storage types","text":"Pages = [\"storage_types.md\"]","category":"page"},{"location":"chains.html#Chains","page":"Chains","title":"Chains","text":"","category":"section"},{"location":"chains.html","page":"Chains","title":"Chains","text":"Daf.Chains\nDaf.Chains.chain_reader\nDaf.Chains.chain_writer\nDaf.Chains.ReadOnlyChain\nDaf.Chains.WriteChain","category":"page"},{"location":"chains.html#Daf.Chains","page":"Chains","title":"Daf.Chains","text":"View a chain of Daf data as a single data set. This allows creating a small Daf data set that contains extra (or overriding) data on top of a larger read-only data set. In particular this allows creating several such incompatible extra data sets (e.g., different groupings of cells to metacells), without having to duplicate the common (read only) data.\n\n\n\n\n\n","category":"module"},{"location":"chains.html#Daf.Chains.chain_reader","page":"Chains","title":"Daf.Chains.chain_reader","text":"chain_reader(name::AbstractString, dafs::Vector{F})::ReadOnlyChain where {F <: DafReader}\n\nCreate a read-only chain wrapper of DafReaders, presenting them as a single DafReader. When accessing the content, the exposed value is that provided by the last data set that contains the data, that is, later data sets can override earlier data sets. However, if an axis exists in more than one data set in the chain, then its entries must be identical. This isn't typically created manually; instead call chain_reader.\n\nnote: Note\nWhile this verifies the axes are consistent at the time of creating the chain, it's no defense against modifying the chained data after the fact, creating inconsistent axes. Don't do that.\n\n\n\n\n\n","category":"function"},{"location":"chains.html#Daf.Chains.chain_writer","page":"Chains","title":"Daf.Chains.chain_writer","text":"chain_writer(name::AbstractString, dafs::Vector{F})::WriteChain where {F <: DafReader}\n\nCreate a chain wrapper for a chain of DafReader data, presenting them as a single DafWriter. This acts similarly to chain_reader, but requires the final entry to be a DafWriter. Any modifications or additions to the chain are directed at this final writer.\n\nnote: Note\nDeletions are only allowed for data that exists only in the final writer. That is, it is impossible to delete from a chain something that exists in any of the readers; it is only possible to override it.\n\n\n\n\n\n","category":"function"},{"location":"chains.html#Daf.Chains.ReadOnlyChain","page":"Chains","title":"Daf.Chains.ReadOnlyChain","text":"struct ReadOnlyChain <: DafReader ... end\n\nA wrapper for a chain of DafReader data, presenting them as a single DafReader. When accessing the content, the exposed value is that provided by the last data set that contains the data, that is, later data sets can override earlier data sets. However, if an axis exists in more than one data set in the chain, then its entries must be identical. This isn't typically created manually; instead call chain_reader.\n\n\n\n\n\n","category":"type"},{"location":"chains.html#Daf.Chains.WriteChain","page":"Chains","title":"Daf.Chains.WriteChain","text":"struct WriteChain <: DafWriter ... end\n\nA wrapper for a chain of DafReader data, with a final [DafWriter], presenting them as a single DafWriter. When accessing the content, the exposed value is that provided by the last data set that contains the data, that is, later data sets can override earlier data sets (where the writer has the final word). However, if an axis exists in more than one data set in the chain, then its entries must be identical. This isn't typically created manually; instead call chain_reader.\n\nAny modifications or additions to the chain are directed at the final writer. Deletions are only allowed for data that exists only in this writer. That is, it is impossible to delete from a chain something that exists in any of the readers; it is only possible to override it.\n\n\n\n\n\n","category":"type"},{"location":"chains.html#Index","page":"Chains","title":"Index","text":"","category":"section"},{"location":"chains.html","page":"Chains","title":"Chains","text":"Pages = [\"chains.md\"]","category":"page"},{"location":"oprec.html#Operator-precedence-parser","page":"Operator precedence parser","title":"Operator precedence parser","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec","category":"page"},{"location":"oprec.html#Daf.Oprec","page":"Operator precedence parser","title":"Daf.Oprec","text":"You can safely skip this module if you are only using Daf. It is an internal module which is only of interest for maintainers. Some of the types here are also used when implementing additional query element-wise or reduction operations. In particular, this isn't reexported by default when using Daf.\n\nIdeally Daf should have used some established parser generator module for parsing queries, making this unnecessary. However, As of writing this code, Julia doesn't seem to have such a parser generator solution. Therefore, this module provides a simple operator precedence based parser generator. The upside is that we can tailor this to our needs (in particular, provide tailored error messages when parsing fails).\n\nOperator-precedence based parsers are simple to define and implement. A set of Regex patterns are used for converting the input string into Tokens. Some tokens are Operators, which have Associativity and precedence. We therefore build an Expression tree from the tokens, and then \"parse\" it into something more convenient to work with.\n\nThis is pretty intuitive when thinking about something like arithmetic expressions 1 + 2 * 3. However, it turns out that this approach allows for parsing a wide range of languages, including languages which one wouldn't immediately think of as \"expressions\", all the way up to full programming languages.\n\nThat said, the implementation here is tailored for parsing Daf queries, and is not general enough to be a package on its own.\n\nSpecifically, we assume that _[0-9A-F][0-9A-F] can't appear inside an operator, which is mostly reasonable; that \\x is used to escape \"special\" characters to allow them in \"normal\" tokens, which isn't typically true in most languages; we don't support postfix operators (e.g., ; in C), we assume all operators are infix (e.g., * in arithmetic), but some can also be prefix (e.g., - in arithmetic); there's no support for parenthesis; and we assume the parsed expressions are \"small\" (can be squashed into a single line) for the purpose of creating friendly error messages.\n\nWe only reexport escape_query, unescape_query and is_safe_query_char from the top-level Daf module itself, as these are all you might be interested in from outside the Daf package.\n\n\n\n\n\n","category":"module"},{"location":"oprec.html#Escaping-special-characters","page":"Operator precedence parser","title":"Escaping special characters","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.escape_query\nDaf.Oprec.unescape_query\nDaf.Oprec.is_safe_query_char","category":"page"},{"location":"oprec.html#Daf.Oprec.escape_query","page":"Operator precedence parser","title":"Daf.Oprec.escape_query","text":"escape_query(token::AbstractString)::String\n\nGiven some raw token (name of an axis, axis entry or property, or a parameter value), which may contain special characters, return an escaped version to be used in a query string.\n\nWe need to consider the following kinds of characters:\n\nSafe (is_safe_query_char) characters include a - z, A - Z, 0 - 9, _, +, -, and ., as well as any non-ASCII (that is, Unicode) characters. Any sequence of these characters will be considered a single token, used to write names (of axes, axis entries, properties, operations, parameters), and also values (for parameters). These cover all the common cases (including signed integer and floating point values).\nAll other ASCII characters are (at least potentially) special, that is, may be used to describe the query structure. Currently only a subset of these are actually used: #, \\, @, :, <, =, ,, ;, !, &, |, ^ and %, and, of course, white space (spaces, tabs and line breaks) which can be used for readability. Additional characters may be used in future version, if we choose to enhance the query language.\nPrefixing any character with a \\ allows using it inside a token. This is useful if some name or value contains a special character. For example, if you have a cell whose name is ACTG:Plate1, and you want to access the name of the batch of this specific cell, you will have to write cell = ACTG\\:Plate1 : batch.\n\nnote: Note\nThe \\ character is also used by Julia inside \"...\" string literals, to escape writing non-printable characters. For example, \"\\n\" is a single-character string containing a line break, and therefore \"\\\\\" is used to write a single \\. Thus the above example would have to be written as \"cell = ACTG\\\\:Plate1 : batch\". This isn't nice.Luckily, Julia also has raw\"...\" string literals that work similarly to Python's r\"...\" strings (in Julia, r\"...\" is a regular expression, not a string). Inside raw string literals, a \\ is a \\ (unless it precedes a \"). Therefore the above example could also be written as raw\"cell = ACTG\\:Plate1 : batch, which is more readable.\n\nBack to escape_query - it will prefix any (potentially) special character with a \\. It is useful if you want to inject a data into a query. Often this happens when using $(...) to embed values into a query string, e.g., the query $(axis) @ $(property) > $(value) is unsafe, as any of the embedded variables may contain unsafe characters. You should instead write something like $(escape_query(axis)) @ $(escape_query(property)) > $(escape_query(value)).\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.unescape_query","page":"Operator precedence parser","title":"Daf.Oprec.unescape_query","text":"unescape_query(escaped_token::AbstractString)::String\n\nUndo escape_query, that is, given a query token with a \\ characters escaping special characters, drop the \\ to get back the original string value.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.is_safe_query_char","page":"Operator precedence parser","title":"Daf.Oprec.is_safe_query_char","text":"is_safe_query_char(character::Char)::Bool\n\nReturn whether a character is safe to use inside a query token (name of an axis, axis entry or property, or a parameter value).\n\nThe safe characters are a - z, A - Z, 0 - 9, _, +, -, and ., as well as any non-ASCII (that is, Unicode) characters.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Encoding-/-decoding","page":"Operator precedence parser","title":"Encoding / decoding","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.encode_expression\nDaf.Oprec.decode_expression","category":"page"},{"location":"oprec.html#Daf.Oprec.encode_expression","page":"Operator precedence parser","title":"Daf.Oprec.encode_expression","text":"Given an expression string to parse, encode any character escaped by a \\ such that it will be considered a normal Token character. Every escaped character is replaced by _XX using URI encoding, but replacing the % with a _ so we can deal with unescaped % as an operator, so we also need to encode _ as _5F, so we need to encode \\_ as _5C_5F. Isn't encoding fun?\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.decode_expression","page":"Operator precedence parser","title":"Daf.Oprec.decode_expression","text":"Given the results of encode_expression, decode it back to its original form.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Syntax","page":"Operator precedence parser","title":"Syntax","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.Syntax\nDaf.Oprec.Operator\nDaf.Oprec.Associativity","category":"page"},{"location":"oprec.html#Daf.Oprec.Syntax","page":"Operator precedence parser","title":"Daf.Oprec.Syntax","text":"struct Syntax{E}\n    space_regex::Regex\n    operand_regex::Regex\n    operator_regex::Regex\n    operators::Dict{String, Operator{E}}\nend\n\nDescribe the syntax to parse using the patterns for tokens.\n\nWhen tokenizing, we try matching the space_regex first. Anything that matches is considered to be white space and discarded. We then try to match the operand_regex. Anything that matches is considered to be an operand Token. Otherwise, we try to match the operator_regex, and look up the result in the operators dictionary to obtain an Operator Token. Anything that doesn't match (or that doesn't exist in the operators) is reported as an invalid character.\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.Operator","page":"Operator precedence parser","title":"Daf.Oprec.Operator","text":"struct Operator{E}\n    id::E\n    is_prefix::Bool\n    associativity::Associativity\n    precedence::Int\nend\n\nDescribe an operator token.\n\nWe attach an arbitrary id to the operators, which is typically used to carry some @enum to identify it for parsing the expression tree.\n\nThe implementation is restricted to operators which are always infix (e.g., + in arithmetic expressions). Some operators can also be is_prefix (e.g., - in arithmetic expressions).\n\nHigher precedence operators (e.g., * in arithmetic expressions) will bind more strongly than lower precedence operators (e.g., + in arithmetic expressions). That is, a + b * c will be parsed as a + (b * c).\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.Associativity","page":"Operator precedence parser","title":"Daf.Oprec.Associativity","text":"For infix operators, how to group a sequence of operators.\n\nLeftAssociative - groups 1 + 2 + 3 as (1 + 2) + 3. Parsing these operators is marginally faster.\n\nRightAssociative - groups 1 + 2 + 3 as 1 + (2 + 3). The current implementation requires this for parsing lists.\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Expression-tree","page":"Operator precedence parser","title":"Expression tree","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.Token\nDaf.Oprec.Operation\nDaf.Oprec.Expression\nDaf.Oprec.build_encoded_expression","category":"page"},{"location":"oprec.html#Daf.Oprec.Token","page":"Operator precedence parser","title":"Daf.Oprec.Token","text":"struct Token{E}\n    first_index::Int\n    last_index::Int\n    string::String\n    operator::Union{Operator{E}, Nothing}\nend\n\nA parsed token of the expression (leaf node in an Expression tree).\n\nThis contains the location (first_index .. last_index) in the (encoded) expression string to enable generating friendly error messages. There are no line numbers in locations because in Daf we squash our queries to a single-line, under the assumption they are \"relatively simple\". This allows us to simplify the code.\n\nWe also hold the (decoded!) string of the token. If the token is an Operator, we also provide its description.\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.Operation","page":"Operator precedence parser","title":"Daf.Oprec.Operation","text":"struct Operation{E}\n    left::Union{Operation{E}, Token{E}, Nothing}\n    token::Token{E}\n    right::Union{Operation{E}, Token{E}}\nend\n\nAn operation (node in an Expression tree).\n\nThe token describes the Operator. There's always a right sub-tree, but for prefix operators, the left sub-tree is nothing.\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.Expression","page":"Operator precedence parser","title":"Daf.Oprec.Expression","text":"Expression{E} = Union{Operation{E}, Token{E}}\n\nAn expression tree - either an Operation or an operand (Token).\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.build_encoded_expression","page":"Operator precedence parser","title":"Daf.Oprec.build_encoded_expression","text":"build_encoded_expression(\n    encoded_string::AbstractString,\n    syntax::Syntax{E},\n)::Union{Expression{E}, Nothing} where {E}\n\nBuild an Expression tree from an encoded_string (that went through encode_expression).\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Context-and-errors","page":"Operator precedence parser","title":"Context and errors","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.Context\nDaf.Oprec.error_in_context","category":"page"},{"location":"oprec.html#Daf.Oprec.Context","page":"Operator precedence parser","title":"Daf.Oprec.Context","text":"Context(encoded_string::AbstractString)\n\nA context for parsing a sub Expression.\n\nWhen processing an Expression tree, we go top-down, collecting context entries along the way. This way, when we discover some invalid construct, we can show this in an error message, helping the user understand how the expression was parsed, and why it is invalid.\n\n\n\n\n\n","category":"type"},{"location":"oprec.html#Daf.Oprec.error_in_context","page":"Operator precedence parser","title":"Daf.Oprec.error_in_context","text":"error_in_context(context::Context{E}, message::AbstractString)::Nothing where {E}\n\nReport a parsing error in some Context.\n\nThis provides location markers for the nested Context that led us to the point where the error occurred. It only works for small (one-line) inputs, where there's little or no recursion in the parsing. Therefore, it is a good fit for Daf queries, but not for a more general parsed languages.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Parsing-trees","page":"Operator precedence parser","title":"Parsing trees","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Daf.Oprec.parse_in_context\nDaf.Oprec.parse_string_in_context\nDaf.Oprec.parse_operand_in_context\nDaf.Oprec.parse_operation_in_context\nDaf.Oprec.parse_list_in_context\nDaf.Oprec.parse_with_list_in_context\nDaf.Oprec.check_operation","category":"page"},{"location":"oprec.html#Daf.Oprec.parse_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_in_context","text":"parse_in_context(\n    parse::Union{Function, Type},\n    context::Context{E},\n    expression::Expression{E};\n    name::AbstractString,\n    operators::Vector{E} = E[],\n)::Any where {E}\n\nParse a node of an Expression, using it as the Context when parsing any sub-expression. That is, push the top-level expression into the context, invoke the parse() function, and pop the expression from the context. Will return the results of the parse function.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.parse_string_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_string_in_context","text":"parse_string_in_context(\n    context::Context{E},\n    expression::Expression{E};\n    name::AbstractString,\n)::AbstractString where {E}\n\nIf the expression is not an operand [Token], report an error_in_context, using the name.\n\nOtherwise, return the string of the operand Token.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.parse_operand_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_operand_in_context","text":"parse_operand_in_context(\n    parse::Union{Function, Type},\n    context::Context{E},\n    expression::Expression{E};\n    name::AbstractString,\n)::Any where {E}\n\nParse an operand in an Expression in some Context.\n\nIf the expression is not an operand [Token], report an error_in_context, using the name.\n\nOtherwise, give the parse function the operand Token, and returns whatever the result it.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.parse_operation_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_operation_in_context","text":"parse_operation_in_context(\n    parse::Union{Function, Type},\n    context::Context{E},\n    expression::Expression{E};\n    expression_name::AbstractString,\n    operator_name::AbstractString,\n    operators::Vector{E},\n)::Any where {E}\n\nParse an operation in an Expression.\n\nIf the expression is not an Operation using one of the listed operators, report an error_in_context using the expression_name and the operator_name.\n\nOtherwise, give the parse function the left sub-Expression (or nothing for a prefix operator), the Token of the operator, and the right sub-Expression.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.parse_list_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_list_in_context","text":"parse_list_in_context(\n    [parse_element::Union{Function, Type},]\n    context::Context{E},\n    expression::Expression{E};\n    list_name::AbstractString,\n    element_type::Type{T},\n    first_operator::Union{Token{E}, Nothing} = nothing,\n    operators::Vector{E},\n)::Vector{T} where {T, E}\n\nThis converts an expression of the form element ( operator element )* into a vector of element, assuming the operators have right Associativity. For example, property_name : property_name : ... for a chained property lookup.\n\nWe repeatedly invoke the parse_element function (or the element_type constructor, if parse_element is not given), with the context (using the list_name), the operator immediately to the left of each sub-expression (using the first_operator for the 1st one), and the sub-expression. We collect the results into a Vector of the element_type.\n\nThis always matches. If the expression isn't an Operation using one of the operators, then this simply returns a single-element vector. That said, naturally parsing the field may fail.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.parse_with_list_in_context","page":"Operator precedence parser","title":"Daf.Oprec.parse_with_list_in_context","text":"parse_with_list_in_context(\n    parse::Union{Function, Type},\n    context::Context{E},\n    expression::Expression{E};\n    expression_name::AbstractString,\n    separator_name::AbstractString,\n    separator_operators::Vector{E},\n    list_name::AbstractString,\n    parse_element::Union{Function, Type, Nothing} = nothing,\n    element_type::Type{L},\n    first_operator::Bool = false,\n    operators::Vector{E},\n)::Any where {L, E}\n\nThis converts an expression of the form something separator element ( operator element )* into a combined object, which typically has two members, a field for something and a vector for one or more element. For example, operation ; parameter_assignment , parameter_assignment , ... for invoking an element-wise or reduction operation.\n\nIf the expression isn't an Operation using one of the separator_operators, then we assume there is no list of elements. Otherwise this invokes parse_list_in_context for collecting the elements. If first_operator, we give it the separator operator as the first operator.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Daf.Oprec.check_operation","page":"Operator precedence parser","title":"Daf.Oprec.check_operation","text":"check_operation(\n    expression::Expression{E},\n    operators::Vector{E}\n)::Union{Token{E}, Nothing} where {E}\n\nCheck whether an expression is an Operation using one of the specified operators. If so, return the operator's Token; otherwise, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"oprec.html#Index","page":"Operator precedence parser","title":"Index","text":"","category":"section"},{"location":"oprec.html","page":"Operator precedence parser","title":"Operator precedence parser","text":"Pages = [\"oprec.md\"]","category":"page"},{"location":"registry.html#Operations-registry","page":"Operations registry","title":"Operations registry","text":"","category":"section"},{"location":"registry.html","page":"Operations registry","title":"Operations registry","text":"Daf.Registry","category":"page"},{"location":"registry.html#Daf.Registry","page":"Operations registry","title":"Daf.Registry","text":"Registering element-wise and reduction operations is required, to allow them to be used in a query.\n\nnote: Note\nWe do not re-export everything from here to the main Daf namespace, as it is only of interest for implementers of new query operations. Most users of Daf just stick with the (fairly comprehensive) list of built-in query operations so there's no need to pollute their namespace with these detail.\n\n\n\n\n\n","category":"module"},{"location":"registry.html#Element-wise-operations","page":"Operations registry","title":"Element-wise operations","text":"","category":"section"},{"location":"registry.html","page":"Operations registry","title":"Operations registry","text":"Daf.Registry.EltwiseOperation\nDaf.Registry.compute_eltwise","category":"page"},{"location":"registry.html#Daf.Registry.EltwiseOperation","page":"Operations registry","title":"Daf.Registry.EltwiseOperation","text":"Abstract type for all element-wise operations.\n\nAn element-wise operation may be applied to matrix or vector data. It will preserve the shape of the data, but changes the values, and possibly the data type of the elements. For example, Abs will compute the absolute value of each element.\n\nTo implement a new such operation, the type is expected to be of the form:\n\nstruct MyOperation <: EltwiseOperation\n    ... optional parameters ...\nend\n@query_operation MyOperation\n\nMyOperation(context::QueryContext, parameters_assignments::Dict{String, QueryOperation})::MyOperation\n\nThe constructor should use parse_parameter for each of the parameters (for example, using parse_number_assignment). In addition you will need to invoke @query_operation to register the operation so it can be used in a query, and implement the functions listed below. See the query operations module for details and examples.\n\n\n\n\n\n","category":"type"},{"location":"registry.html#Daf.Registry.compute_eltwise","page":"Operations registry","title":"Daf.Registry.compute_eltwise","text":"compute_eltwise(operation::EltwiseOperation, input::StorageMatrix)::StorageMatrix\ncompute_eltwise(operation::EltwiseOperation, input::StorageVector)::StorageVector\ncompute_eltwise(operation::EltwiseOperation, input_value::Number)::Number\n\nCompute an EltwiseOperation operation.\n\n\n\n\n\n","category":"function"},{"location":"registry.html#Reduction-operations","page":"Operations registry","title":"Reduction operations","text":"","category":"section"},{"location":"registry.html","page":"Operations registry","title":"Operations registry","text":"Daf.Registry.ReductionOperation\nDaf.Registry.compute_reduction","category":"page"},{"location":"registry.html#Daf.Registry.ReductionOperation","page":"Operations registry","title":"Daf.Registry.ReductionOperation","text":"Abstract type for all reduction operations.\n\nA reduction operation may be applied to matrix or vector data. It will reduce (eliminate) one dimension of the data, and possibly the result will have a different data type than the input. When applied to a vector, the operation will return a scalar. When applied to a matrix, it assumes the matrix is in column-major layout, and will return a vector with one entry per column, containing the result of reducing the column to a scalar.\n\nTo implement a new such operation, the type is expected to be of the form:\n\nstruct MyOperation <: ReductionOperation\n    ... optional parameters ...\nend\n\nMyOperation(context::QueryContext, parameters_assignments::Dict{String, QueryOperation})::MyOperation\n\nThe constructor should use parse_parameter for each of the parameters (for example, using typically parse_number_assignment). In addition you will need to invoke @query_operation to register the operation so it can be used in a query, and implement the functions listed below. See the query operations module for details and examples.\n\n\n\n\n\n","category":"type"},{"location":"registry.html#Daf.Registry.compute_reduction","page":"Operations registry","title":"Daf.Registry.compute_reduction","text":"compute_reduction(operation::ReductionOperation, input::StorageMatrix)::StorageVector\ncompute_reduction(operation::ReductionOperation, input::StorageVector)::Number\n\nCompute an ReductionOperation operation.\n\n\n\n\n\n","category":"function"},{"location":"registry.html#Registering-operations","page":"Operations registry","title":"Registering operations","text":"","category":"section"},{"location":"registry.html","page":"Operations registry","title":"Operations registry","text":"Daf.Registry.@query_operation\nDaf.Registry.register_query_operation","category":"page"},{"location":"registry.html#Daf.Registry.@query_operation","page":"Operations registry","title":"Daf.Registry.@query_operation","text":"struct MyOperation <: EltwiseOperation  # Or <: ReductionOperation\n    ...\nend\n@query_operation MyOperation\n\nAutomatically call register_query_operation for MyOperation.\n\nNote this will import Daf.Registry.register_query_operation, so it may only be called from the top level scope of a module.\n\n\n\n\n\n","category":"macro"},{"location":"registry.html#Daf.Registry.register_query_operation","page":"Operations registry","title":"Daf.Registry.register_query_operation","text":"function register_query_operation(\n    type::Type{T},\n    source_file::AbstractString,\n    source_line::Integer,\n)::Nothing where {T <: Union{EltwiseOperation, ReductionOperation}}\n\nRegister a specific operation so it would be available inside queries. This is required to be able to parse the operation. This is idempotent (safe to invoke multiple times).\n\nThis isn't usually called directly. Instead, it is typically invoked by using the @query_operation macro.\n\n\n\n\n\n","category":"function"},{"location":"registry.html#Index","page":"Operations registry","title":"Index","text":"","category":"section"},{"location":"registry.html","page":"Operations registry","title":"Operations registry","text":"Pages = [\"registry.md\"]","category":"page"},{"location":"computations.html#Computations","page":"Computations","title":"Computations","text":"","category":"section"},{"location":"computations.html","page":"Computations","title":"Computations","text":"Daf.Computations\nDaf.Computations.@computation\nDaf.Computations.DEFAULT\nDaf.Computations.CONTRACT\nDaf.Computations.CONTRACT1\nDaf.Computations.CONTRACT2","category":"page"},{"location":"computations.html#Daf.Computations","page":"Computations","title":"Daf.Computations","text":"Support writing \"well-behaved\" computations. Such computations declare a Contract describing their inputs and outputs. This is enforced, so that the implementation need not worry about missing inputs, and the caller can rely on the results. It is also self-documenting, so the generated documentation is always contains a clear up-to-date description of the contract.\n\n\n\n\n\n","category":"module"},{"location":"computations.html#Daf.Computations.@computation","page":"Computations","title":"Daf.Computations.@computation","text":"@computation function something(...)\n    return ...\nend\n\n@computation Contract(...) function something(daf::DafWriter, ...)\n    return ...\nend\n\n@computation Contract(...) Contract(...) function something(\n    first::DafReader/DafWriter, second::DafReader/DafWriter, ...\n)\n    return ...\nend\n\nMark a function as a daf computation. This has the following effects:\n\nIt verifies that the daf data satisfies the Contract, when the computation is invoked and when it is complete (using verify_input and verify_output).\nIt stashes the contract(s) (if any) in a global variable. This allows expanding CONTRACT in the documentation string (for a single contract case), or CONTRACT1 and CONTRACT2 (for the dual contract case).\nIt stashes the default value of named arguments. This allows expanding DEFAULT in the documentation string, which is especially useful if these defaults are computed, read from global constants, etc.\nIt logs the invocation of the function (using @debug), including the actual values of the named arguments (using [present]).\n\nnote: Note\nFor each Contract parameter (if any), there needs to be a DafReader or DafWriter, which the contract(s) will be applied to. These parameters should be the initial positional parameters of the function.\n\n\n\n\n\n","category":"macro"},{"location":"computations.html#Daf.Computations.DEFAULT","page":"Computations","title":"Daf.Computations.DEFAULT","text":"When using @computation:\n\n'''\n    something(daf::DafWriter, x::Int = $(DEFAULT.x); y::Bool = $(DEFAULT.y))\n\n...\nIf `x` (default: $(DEFAULT.y)) is even, ...\n...\nIf `y` (default: $(DEFAULT.y)) is set, ...\n...\n'''\n@computation Contract(...)\nfunction something(daf::DafWriter, x::Int = 0; y::Bool = false)\n    return ...\nend\n\nThen $(DEFAULT.x) will be expanded with the default value of the parameter x. It is good practice to contain a description of the effects of each parameter somewhere in the documentation, and it is polite to also provide its default value. This can be done in either the signature line or in the text, or both. Using DEFAULT ensures that the correct value is used in the documentation.\n\n\n\n\n\n","category":"constant"},{"location":"computations.html#Daf.Computations.CONTRACT","page":"Computations","title":"Daf.Computations.CONTRACT","text":"When using @computation:\n\n'''\n...\n# Contract\n...\n$(CONTRACT)\n...\n'''\n@computation Contract(...)\nfunction something(daf::DafWriter, ...)\n    return ...\nend\n\nThen $(CONTRACT) will be expanded with a description of the Contract. This is based on DocStringExtensions.\n\nnote: Note\nThe first argument of the function must be a DafWriter, which the contract will be applied to.\n\n\n\n\n\n","category":"constant"},{"location":"computations.html#Daf.Computations.CONTRACT1","page":"Computations","title":"Daf.Computations.CONTRACT1","text":"Same as CONTRACT, but reference the contract for the 1st daf argument for a @computation with two such arguments.\n\n\n\n\n\n","category":"constant"},{"location":"computations.html#Daf.Computations.CONTRACT2","page":"Computations","title":"Daf.Computations.CONTRACT2","text":"Same as CONTRACT, but reference the contract for the 2nd daf argument for a @computation with two such arguments.\n\n\n\n\n\n","category":"constant"},{"location":"computations.html#Index","page":"Computations","title":"Index","text":"","category":"section"},{"location":"computations.html","page":"Computations","title":"Computations","text":"Pages = [\"computations.md\"]","category":"page"},{"location":"data.html#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data","category":"page"},{"location":"data.html#Daf.Data","page":"Data","title":"Daf.Data","text":"The DafReader and DafWriter interfaces specify a high-level API for accessing Daf data. This API is implemented here, on top of the low-level FormatReader and FormatWriter API.\n\nData properties are identified by a unique name given the axes they are based on. That is, there is a separate namespace for scalar properties, vector properties for each specific axis, and matrix properties for each unordered pair of axes.\n\nFor matrices, we keep careful track of their MatrixLayouts. Returned matrices are always in column-major layout, using relayout! if necessary. As this is an expensive operation, we'll cache the result in memory. Similarly, we cache the results of applying a query to the data. We allow clearing the cache to reduce memory usage, if necessary.\n\nThe data API is the high-level API intended to be used from outside the package, and is therefore re-exported from the top-level Daf namespace. It provides additional functionality on top of the low-level FormatReader and FormatWriter implementations, accepting more general data types, automatically dealing with relayout! when needed, and even providing a language for ParseQueries for flexible extraction of data from the container.\n\nnote: Note\nIn the APIs below, when getting a value, specifying a default of undef means that it is an error for the value not to exist. In contrast, specifying a default of nothing means it is OK for the value not to exist, returning nothing, while specifying an actual value for default means it is OK for the value not to exist, returning the default instead. This is in spirit with, but not identical to, undef being used as a flag for array construction saying \"there is no initializer\". If you feel this is an abuse of the value, take some comfort in that this is the default value for default so you almost never have to write it explicitly in your code.\n\n\n\n\n\n","category":"module"},{"location":"data.html#Read-API","page":"Data","title":"Read API","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.description","category":"page"},{"location":"data.html#Daf.Data.description","page":"Data","title":"Daf.Data.description","text":"description(daf::DafReader[; deep::Bool = false])::AbstractString\n\nReturn a (multi-line) description of the contents of daf. This tries to hit a sweet spot between usefulness and terseness. If deep, also describes any data set nested inside this one (if any).\n\n\n\n\n\n","category":"function"},{"location":"data.html#Scalar-properties","page":"Data","title":"Scalar properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.has_scalar\nDaf.Data.get_scalar","category":"page"},{"location":"data.html#Daf.Data.has_scalar","page":"Data","title":"Daf.Data.has_scalar","text":"has_scalar(daf::DafReader, name::AbstractString)::Bool\n\nCheck whether a scalar property with some name exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.get_scalar","page":"Data","title":"Daf.Data.get_scalar","text":"get_scalar(\n    daf::DafReader,\n    name::AbstractString;\n    [default::Union{StorageScalar, Nothing, UndefInitializer} = undef]\n)::Union{StorageScalar, Nothing}\n\nGet the value of a scalar property with some name in daf.\n\nIf default is undef (the default), this first verifies the name scalar property exists in daf. Otherwise default will be returned if the property does not exist.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Data-axes","page":"Data","title":"Data axes","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.has_axis\nDaf.Data.axis_names\nDaf.Data.get_axis\nDaf.Data.axis_length","category":"page"},{"location":"data.html#Daf.Data.has_axis","page":"Data","title":"Daf.Data.has_axis","text":"has_axis(daf::DafReader, axis::AbstractString)::Bool\n\nCheck whether some axis exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.axis_names","page":"Data","title":"Daf.Data.axis_names","text":"axis_names(daf::DafReader)::AbstractSet{String}\n\nThe names of the axes of daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.get_axis","page":"Data","title":"Daf.Data.get_axis","text":"get_axis(\n    daf::DafReader,\n    axis::AbstractString\n    [; default::Union{Nothing, UndefInitializer} = undef]\n)::Union{AbstractVector{String}, Nothing}\n\nThe unique names of the entries of some axis of daf. This is similar to doing get_vector for the special name property, except that it returns a simple vector of strings instead of a NamedVector.\n\nIf default is undef (the default), this verifies the axis exists in daf. Otherwise, the default is nothing, which is returned if the axis does not exist.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.axis_length","page":"Data","title":"Daf.Data.axis_length","text":"axis_length(daf::DafReader, axis::AbstractString)::Int64\n\nThe number of entries along the axis in daf.\n\nThis first verifies the axis exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Vector-properties","page":"Data","title":"Vector properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.has_vector\nDaf.Data.vector_names\nDaf.Data.get_vector","category":"page"},{"location":"data.html#Daf.Data.has_vector","page":"Data","title":"Daf.Data.has_vector","text":"has_vector(daf::DafReader, axis::AbstractString, name::AbstractString)::Bool\n\nCheck whether a vector property with some name exists for the axis in daf. This is always true for the special name property.\n\nThis first verifies the axis exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.vector_names","page":"Data","title":"Daf.Data.vector_names","text":"vector_names(daf::DafReader, axis::AbstractString)::Set{String}\n\nThe names of the vector properties for the axis in daf, not including the special name property.\n\nThis first verifies the axis exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.get_vector","page":"Data","title":"Daf.Data.get_vector","text":"get_vector(\n    daf::DafReader,\n    axis::AbstractString,\n    name::AbstractString;\n    [default::Union{StorageScalar, StorageVector, Nothing, UndefInitializer} = undef]\n)::Union{NamedVector, Nothing}\n\nGet the vector property with some name for some axis in daf. The names of the result are the names of the vector entries (same as returned by get_axis). The special property name returns an array whose values are also the (read-only) names of the entries of the axis.\n\nThis first verifies the axis exists in daf. If default is undef (the default), this first verifies the name vector exists in daf. Otherwise, if default is nothing, it will be returned. If it is a StorageVector, it has to be of the same size as the axis, and is returned. If it is a StorageScalar. Otherwise, a new Vector is created of the correct size containing the default, and is returned.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Matrix-properties","page":"Data","title":"Matrix properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.has_matrix\nDaf.Data.matrix_names\nDaf.Data.get_matrix","category":"page"},{"location":"data.html#Daf.Data.has_matrix","page":"Data","title":"Daf.Data.has_matrix","text":"has_matrix(\n    daf::DafReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString;\n    [relayout::Bool = true]\n)::Bool\n\nCheck whether a matrix property with some name exists for the rows_axis and the columns_axis in daf. Since this is Julia, this means a column-major matrix. A daf may contain two copies of the same data, in which case it would report the matrix under both axis orders.\n\nIf relayout (the default), this will also check whether the data exists in the other layout (that is, with flipped axes).\n\nThis first verifies the rows_axis and columns_axis exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.matrix_names","page":"Data","title":"Daf.Data.matrix_names","text":"matrix_names(\n    daf::DafReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString;\n    [relayout::Bool = true]\n)::Set{String}\n\nThe names of the matrix properties for the rows_axis and columns_axis in daf.\n\nIf relayout (default), then this will include the names of matrices that exist in the other layout (that is, with flipped axes).\n\nThis first verifies the rows_axis and columns_axis exist in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.get_matrix","page":"Data","title":"Daf.Data.get_matrix","text":"get_matrix(\n    daf::DafReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString;\n    [default::Union{StorageScalar, StorageMatrix, Nothing, UndefInitializer} = undef,\n    relayout::Bool = true]\n)::Union{NamedMatrix, Nothing}\n\nGet the column-major matrix property with some name for some rows_axis and columns_axis in daf. The names of the result axes are the names of the relevant axes entries (same as returned by get_axis).\n\nIf relayout (the default), then if the matrix is only stored in the other memory layout (that is, with flipped axes), then automatically call relayout! to compute the result. If daf isa DafWriter, then store the result for future use; otherwise, just cache it in-memory (similar to a query result). This may lock up very large amounts of memory; you can call empty_cache! to release it.\n\nThis first verifies the rows_axis and columns_axis exist in daf. If default is undef (the default), this first verifies the name matrix exists in daf. Otherwise, if default is nothing, it is returned. If default is a StorageMatrix, it has to be of the same size as the rows_axis and columns_axis, and is returned. Otherwise, a new Matrix is created of the correct size containing the default, and is returned.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Write-API","page":"Data","title":"Write API","text":"","category":"section"},{"location":"data.html#Scalar-properties-2","page":"Data","title":"Scalar properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.set_scalar!\nDaf.Data.delete_scalar!\nDaf.Data.scalar_names","category":"page"},{"location":"data.html#Daf.Data.set_scalar!","page":"Data","title":"Daf.Data.set_scalar!","text":"set_scalar!(\n    daf::DafWriter,\n    name::AbstractString,\n    value::StorageScalar;\n    [overwrite::Bool = false]\n)::Nothing\n\nSet the value of a scalar property with some name in daf.\n\nIf not overwrite (the default), this first verifies the name scalar property does not exist.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.delete_scalar!","page":"Data","title":"Daf.Data.delete_scalar!","text":"delete_scalar!(\n    daf::DafWriter,\n    name::AbstractString;\n    must_exist::Bool = true,\n)::Nothing\n\nDelete a scalar property with some name from daf.\n\nIf must_exist (the default), this first verifies the name scalar property exists in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.scalar_names","page":"Data","title":"Daf.Data.scalar_names","text":"scalar_names(daf::DafReader)::Set{String}\n\nThe names of the scalar properties in daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Data-axes-2","page":"Data","title":"Data axes","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.add_axis!\nDaf.Data.delete_axis!","category":"page"},{"location":"data.html#Daf.Data.add_axis!","page":"Data","title":"Daf.Data.add_axis!","text":"add_axis!(\n    daf::DafWriter,\n    axis::AbstractString,\n    entries::AbstractVector{String}\n)::Nothing\n\nAdd a new axis daf.\n\nThis first verifies the axis does not exist and that the entries are unique.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.delete_axis!","page":"Data","title":"Daf.Data.delete_axis!","text":"delete_axis!(\n    daf::DafWriter,\n    axis::AbstractString;\n    must_exist::Bool = true,\n)::Nothing\n\nDelete an axis from the daf. This will also delete any vector or matrix properties that are based on this axis.\n\nIf must_exist (the default), this first verifies the axis exists in the daf.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Vector-properties-2","page":"Data","title":"Vector properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.set_vector!\nDaf.Data.delete_vector!","category":"page"},{"location":"data.html#Daf.Data.set_vector!","page":"Data","title":"Daf.Data.set_vector!","text":"set_vector!(\n    daf::DafWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    vector::Union{StorageScalar, StorageVector};\n    [overwrite::Bool = false]\n)::Nothing\n\nSet a vector property with some name for some axis in daf.\n\nIf the vector specified is actually a StorageScalar, the stored vector is filled with this value.\n\nThis first verifies the axis exists in daf, that the property name isn't name, and that the vector has the appropriate length. If not overwrite (the default), this also verifies the name vector does not exist for the axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.delete_vector!","page":"Data","title":"Daf.Data.delete_vector!","text":"delete_vector!(\n    daf::DafWriter,\n    axis::AbstractString,\n    name::AbstractString;\n    must_exist::Bool = true,\n)::Nothing\n\nDelete a vector property with some name for some axis from daf.\n\nThis first verifies the axis exists in daf and that the property name isn't name. If must_exist (the default), this also verifies the name vector exists for the axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Matrix-properties-2","page":"Data","title":"Matrix properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.set_matrix!\nDaf.Data.relayout_matrix!\nDaf.Data.delete_matrix!","category":"page"},{"location":"data.html#Daf.Data.set_matrix!","page":"Data","title":"Daf.Data.set_matrix!","text":"set_matrix!(\n    daf::DafWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    matrix::StorageMatrix;\n    [overwrite::Bool = false,\n    relayout::Bool = true]\n)::Nothing\n\nSet the matrix property with some name for some rows_axis and columns_axis in daf. Since this is Julia, this should be a column-major matrix.\n\nIf the matrix specified is actually a StorageScalar, the stored matrix is filled with this value.\n\nIf relayout (the default), this will also automatically relayout! the matrix and store the result, so the data would also be stored in row-major layout (that is, with the axes flipped), similarly to calling relayout_matrix!.\n\nThis first verifies the rows_axis and columns_axis exist in daf, that the matrix is column-major of the appropriate size. If not overwrite (the default), this also verifies the name matrix does not exist for the rows_axis and columns_axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.relayout_matrix!","page":"Data","title":"Daf.Data.relayout_matrix!","text":"relayout_matrix!(\n    daf::DafWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString;\n    [overwrite::Bool = false]\n)::Nothing\n\nGiven a matrix property with some name exists (in column-major layout) in daf for the rows_axis and the columns_axis, then relayout! it and store the row-major result as well (that is, with flipped axes).\n\nThis is useful following calling empty_dense_matrix! or empty_sparse_matrix! to ensure both layouts of the matrix are stored in def. When calling set_matrix!, it is simpler to just specify (the default) relayout = true.\n\nThis first verifies the rows_axis and columns_axis exist in daf, and that there is a name (column-major) matrix property for them. If not overwrite (the default), this also verifies the name matrix does not exist for the flipped rows_axis and columns_axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.delete_matrix!","page":"Data","title":"Daf.Data.delete_matrix!","text":"delete_matrix!(\n    daf::DafWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString;\n    [must_exist::Bool = true,\n    relayout::Bool = true]\n)::Nothing\n\nDelete a matrix property with some name for some rows_axis and columns_axis from daf.\n\nIf relayout (the default), this will also delete the matrix in the other layout (that is, with flipped axes).\n\nThis first verifies the rows_axis and columns_axis exist in daf. If must_exist (the default), this also verifies the name matrix exists for the rows_axis and columns_axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Creating-properties","page":"Data","title":"Creating properties","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Daf.Data.empty_dense_vector!\nDaf.Data.empty_sparse_vector!\nDaf.Data.empty_dense_matrix!\nDaf.Data.empty_sparse_matrix!","category":"page"},{"location":"data.html#Daf.Data.empty_dense_vector!","page":"Data","title":"Daf.Data.empty_dense_vector!","text":"empty_dense_vector!(\n    fill::Function,\n    daf::DafWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T};\n    [overwrite::Bool = false]\n)::Any where {T <: Number}\n\nCreate an empty dense vector property with some name for some axis in daf, pass it to fill, and return the result.\n\nThe returned vector will be uninitialized; the caller is expected to fill it with values. This saves creating a copy of the vector before setting it in the data, which makes a huge difference when creating vectors on disk (using memory mapping). For this reason, this does not work for strings, as they do not have a fixed size.\n\nThis first verifies the axis exists in daf and that the property name isn't name. If not overwrite (the default), this also verifies the name vector does not exist for the axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.empty_sparse_vector!","page":"Data","title":"Daf.Data.empty_sparse_vector!","text":"empty_sparse_vector!(\n    fill::Function,\n    daf::DafWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n    nnz::Integer,\n    indtype::Type{I};\n    [overwrite::Bool = false]\n)::Any where {T <: Number, I <: Integer}\n\nCreate an empty sparse vector property with some name for some axis in daf, pass it to fill and return the result.\n\nThe returned vector will be uninitialized; the caller is expected to fill it with values. This means manually filling the nzind and nzval vectors. Specifying the nnz makes their sizes known in advance, to allow pre-allocating disk data. For this reason, this does not work for strings, as they do not have a fixed size.\n\nThis severely restricts the usefulness of this function, because typically nnz is only know after fully computing the matrix. Still, in some cases a large sparse vector is created by concatenating several smaller ones; this function allows doing so directly into the data vector, avoiding a copy in case of memory-mapped disk formats.\n\nwarning: Warning\nIt is the caller's responsibility to fill the three vectors with valid data. Specifically, you must ensure:nzind[1] == 1\nnzind[i] <= nzind[i + 1]\nnzind[end] == nnz\n\nThis first verifies the axis exists in daf and that the property name isn't name. If not overwrite (the default), this also verifies the name vector does not exist for the axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.empty_dense_matrix!","page":"Data","title":"Daf.Data.empty_dense_matrix!","text":"empty_dense_matrix!(\n    fill::Function,\n    daf::DafWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T};\n    [overwrite::Bool = false]\n)::Any where {T <: Number}\n\nCreate an empty dense matrix property with some name for some rows_axis and columns_axis in daf, pass it to fill, and return the result. Since this is Julia, this will be a column-major matrix.\n\nThe returned matrix will be uninitialized; the caller is expected to fill it with values. This saves creating a copy of the matrix before setting it in daf, which makes a huge difference when creating matrices on disk (using memory mapping). For this reason, this does not work for strings, as they do not have a fixed size.\n\nThis first verifies the rows_axis and columns_axis exist in daf, that the matrix is column-major of the appropriate size. If not overwrite (the default), this also verifies the name matrix does not exist for the rows_axis and columns_axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Daf.Data.empty_sparse_matrix!","page":"Data","title":"Daf.Data.empty_sparse_matrix!","text":"empty_sparse_matrix!(\n    fill::Function,\n    daf::DafWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n    nnz::Integer,\n    intdype::Type{I};\n    [overwrite::Bool = false]\n)::Any where {T <: Number, I <: Integer}\n\nCreate an empty sparse matrix property with some name for some rows_axis and columns_axis in daf, pass it to fill, and return the result.\n\nThe returned matrix will be uninitialized; the caller is expected to fill it with values. This means manually filling the colptr, rowval and nzval vectors. Specifying the nnz makes their sizes known in advance, to allow pre-allocating disk space. For this reason, this does not work for strings, as they do not have a fixed size.\n\nThis severely restricts the usefulness of this function, because typically nnz is only know after fully computing the matrix. Still, in some cases a large sparse matrix is created by concatenating several smaller ones; this function allows doing so directly into the data, avoiding a copy in case of memory-mapped disk formats.\n\nwarning: Warning\n\n\nhttps://science.slashdot.org/story/23/08/12/1942234/common-alzheimers-disease-gene-may-have-helped-our-ancestors-have-more-kids It is the caller's responsibility to fill the three vectors with valid data. Specifically, you must ensure:\n\n  - `colptr[1] == 1`\n  - `colptr[end] == nnz + 1`\n  - `colptr[i] <= colptr[i + 1]`\n  - for all `j`, for all `i` such that `colptr[j] <= i` and `i + 1 < colptr[j + 1]`, `1 <= rowptr[i] < rowptr[i + 1] <= nrows`\n\nThis first verifies the rows_axis and columns_axis exist in daf. If not overwrite (the default), this also verifies the name matrix does not exist for the rows_axis and columns_axis.\n\n\n\n\n\n","category":"function"},{"location":"data.html#Index","page":"Data","title":"Index","text":"","category":"section"},{"location":"data.html","page":"Data","title":"Data","text":"Pages = [\"data.md\"]","category":"page"},{"location":"contracts.html#Contracts","page":"Contracts","title":"Contracts","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Daf.Contracts\nDaf.Contracts.Contract\nDaf.Contracts.Expectation\nDaf.Contracts.verify_input\nDaf.Contracts.verify_output","category":"page"},{"location":"contracts.html#Daf.Contracts","page":"Contracts","title":"Daf.Contracts","text":"Enforce input and output contracts of computations using Daf data.\n\n\n\n\n\n","category":"module"},{"location":"contracts.html#Daf.Contracts.Contract","page":"Contracts","title":"Daf.Contracts.Contract","text":"function Contract([;\n    scalars::Union{\n        Vector{Pair{\n            AbstractString,\n            Tuple{Expectation, Type, AbstractString}\n        }}, Nothing\n    } = nothing,\n    axes::Union{\n        Vector{Pair{\n            AbstractString,\n            Tuple{Expectation, AbstractString}\n        }}, Nothing\n    } = nothing,\n    vectors::Union{\n        Vector{Pair{\n            Tuple{AbstractString, AbstractString},\n            Tuple{Expectation, Type, AbstractString}\n        }},\n        Nothing\n    } = nothing,\n    matrices::Union{\n        Vector{Pair{\n            Tuple{AbstractString, AbstractString, AbstractString},\n            Tuple{Expectation, Type, AbstractString}\n        }},\n        Nothing\n    } = nothing,\n])::Contract\n\nThe contract of a computational tool. This consists of four separate parts:\n\nscalars - a vector of pairs where the key is the scalar name and the value is a tuple of the Expectation, the data type of the scalar, and a description of the scalar (for documentation).\n\naxes - a vector of pairs where the key is the axis name and the value is a tuple of the Expectation and a description of the axis (for documentation). Axes are listed mainly for documentation; axes of required or guaranteed vectors or matrices are automatically required or guaranteed to match. However it is considered polite to explicitly list the axes with their descriptions so the documentation of the contract will be complete.\n\nvectors - a vector of pairs where the key is a tuple of the axis and vector names, and the value is a tuple of the Expectation, the data type of the vector entries, and a description of the vector (for documentation).\n\nmatrices - a vector of pairs where the key is a tuple of the axes and matrix names, and the value is a tuple of the Expectation, the data type of the matrix entries, and a description of the matrix (for documentation).\n\n\n\n\n\n","category":"type"},{"location":"contracts.html#Daf.Contracts.Expectation","page":"Contracts","title":"Daf.Contracts.Expectation","text":"The expectation from a specific entity for a computation on Daf data.\n\nRequired - data that must exist in the data when invoking the computation, will be used as input.\n\nOptional - data that, if existing in the data when invoking the computation, will be used as an input.\n\nGuaranteed - data that is guaranteed to exist when the computation is done.\n\nContingent - data that may exist when the computation is done, contingent on some condition, which may include the existence of optional input and/or the value of parameters to the computation, and/or the content of the data.\n\n\n\n\n\n","category":"type"},{"location":"contracts.html#Daf.Contracts.verify_input","page":"Contracts","title":"Daf.Contracts.verify_input","text":"function verify_input(daf::DafReader, contract::Contract, computation::String)::Nothing\n\nVerify the daf data when a computation is invoked. This verifies that all the required data exists and is of the appropriate type, and that if any of the optional data exists, it has the appropriate type.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Daf.Contracts.verify_output","page":"Contracts","title":"Daf.Contracts.verify_output","text":"function verify_output(daf::DafReader, contract::Contract, computation::String)::Nothing\n\nVerify the daf data when a computation is complete. This verifies that all the guaranteed data exists and is of the appropriate type, and that if any of the contingent data exists, it has the appropriate type.\n\n\n\n\n\n","category":"function"},{"location":"contracts.html#Index","page":"Contracts","title":"Index","text":"","category":"section"},{"location":"contracts.html","page":"Contracts","title":"Contracts","text":"Pages = [\"contracts.md\"]","category":"page"},{"location":"messages.html#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages.html","page":"Messages","title":"Messages","text":"Daf.Messages","category":"page"},{"location":"messages.html#Daf.Messages","page":"Messages","title":"Daf.Messages","text":"Functions for improving the quality of error and log messages.\n\n\n\n\n\n","category":"module"},{"location":"messages.html","page":"Messages","title":"Messages","text":"Daf.Messages.unique_name\nDaf.Messages.present\nDaf.Messages.present_percent","category":"page"},{"location":"messages.html#Daf.Messages.unique_name","page":"Messages","title":"Daf.Messages.unique_name","text":"unique_name(prefix::AbstractString)::String\n\nUsing short, human-readable unique names for things is a great help when debugging. Normally one has to choose between using a human-provided short non-unique name, and an opaque object identifier, or a combination thereof. This function replaces the opaque object identifier with a short counter, which gives names that are both unique and short.\n\nThat is, this will return a unique name starting with the prefix and followed by #, the process index (if using multiple processes), and an index (how many times this name was used in the process). For example, unique_name(\"foo\") will return foo#1 for the first usage, foo#2 for the 2nd, etc., and if using multiple processes, will return foo#1.1, foo#1.2, etc.\n\nTo help with tests, if the prefix ends with !, we return it as-is, accepting it may not be unique.\n\n\n\n\n\n","category":"function"},{"location":"messages.html#Daf.Messages.present","page":"Messages","title":"Daf.Messages.present","text":"present(value::Any)::String\n\nPresent a value in an error message or a log entry. Unlike \"$(value)\", this focuses on producing a human-readable indication of the type of the value, so it double-quotes strings, prefixes symbols with :, and reports the type and sizes of arrays rather than showing their content.\n\n\n\n\n\n","category":"function"},{"location":"messages.html#Daf.Messages.present_percent","page":"Messages","title":"Daf.Messages.present_percent","text":"present_percent(used::Integer, out_of::Integer)::String\n\nPresent a fraction of used amount out_of some total as a percentage.\n\n\n\n\n\n","category":"function"},{"location":"messages.html#Index","page":"Messages","title":"Index","text":"","category":"section"},{"location":"messages.html","page":"Messages","title":"Messages","text":"Pages = [\"messages.md\"]","category":"page"},{"location":"matrix_layouts.html#Matrix-layouts","page":"Matrix layouts","title":"Matrix layouts","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Daf.MatrixLayouts","category":"page"},{"location":"matrix_layouts.html#Daf.MatrixLayouts","page":"Matrix layouts","title":"Daf.MatrixLayouts","text":"All stored Daf matrix data has a clear matrix layout, that is, a major_axis, regardless of whether it is dense or sparse.\n\nThat is, for Columns-major data, the values of each column are laid out consecutively in memory (each column is a single contiguous vector), so any operation that works on whole columns will be fast (e.g., summing the value of each column). In contrast, the values of each row are stored far apart from each other, so any operation that works on whole rows will be very slow in comparison (e.g., summing the value of each row).\n\nFor Rows-major data, the values of each row are laid out consecutively in memory (each row is a single contiguous vector). In contrast, the values of each column are stored far apart from each other. In this case, summing columns would be slow, and summing rows would be fast.\n\nThis is much simpler than the ArrayLayouts module which attempts to fully describe the layout of N-dimensional arrays, a much more ambitious goal which is an overkill for our needs.\n\nnote: Note\nThe \"default\" layout in Julia is column-major, which inherits this from matlab, which inherits this from FORTRAN, allegedly because this is more efficient for some linear algebra operations. In contrast, Python numpy uses row-major layout by default. In either case, this is just an arbitrary convention, and all systems work just fine with data of either memory layout; the key consideration is to keep track of the layout, and to apply operations \"with the grain\" rather than \"against the grain\" of the data.\n\n\n\n\n\n","category":"module"},{"location":"matrix_layouts.html#Symbolic-names-for-axes","page":"Matrix layouts","title":"Symbolic names for axes","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Daf.MatrixLayouts.Rows\nDaf.MatrixLayouts.Columns\nDaf.MatrixLayouts.axis_name","category":"page"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.Rows","page":"Matrix layouts","title":"Daf.MatrixLayouts.Rows","text":"A symbolic name for the rows axis. It is much more readable to write, say, size(matrix, Rows), instead of size(matrix, 1).\n\n\n\n\n\n","category":"constant"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.Columns","page":"Matrix layouts","title":"Daf.MatrixLayouts.Columns","text":"A symbolic name for the rows axis. It is much more readable to write, say, size(matrix, Columns), instead of size(matrix, 2).\n\n\n\n\n\n","category":"constant"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.axis_name","page":"Matrix layouts","title":"Daf.MatrixLayouts.axis_name","text":"axis_name(axis::Union{Integer, Nothing})::String\n\nReturn the name of the axis (for messages).\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Checking-layout","page":"Matrix layouts","title":"Checking layout","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Daf.MatrixLayouts.major_axis\nDaf.MatrixLayouts.require_major_axis\nDaf.MatrixLayouts.minor_axis\nDaf.MatrixLayouts.require_minor_axis\nDaf.MatrixLayouts.other_axis","category":"page"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.major_axis","page":"Matrix layouts","title":"Daf.MatrixLayouts.major_axis","text":"major_axis(matrix::AbstractMatrix)::Union{Int8,Nothing}\n\nReturn the index of the major axis of a matrix, that is, the axis one should keep fixed for an efficient loop accessing the matrix elements. If the matrix doesn't support any efficient access axis, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.require_major_axis","page":"Matrix layouts","title":"Daf.MatrixLayouts.require_major_axis","text":"require_major_axis(matrix::AbstractMatrix)::Int8\n\nSimilar to major_axis but will error if the matrix isn't in either row-major or column-major layout.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.minor_axis","page":"Matrix layouts","title":"Daf.MatrixLayouts.minor_axis","text":"minor_axis(matrix::AbstractMatrix)::Union{Int8,Nothing}\n\nReturn the index of the minor axis of a matrix, that is, the axis one should vary for an efficient loop accessing the matrix elements. If the matrix doesn't support any efficient access axis, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.require_minor_axis","page":"Matrix layouts","title":"Daf.MatrixLayouts.require_minor_axis","text":"require_minor_axis(matrix::AbstractMatrix)::Int8\n\nSimilar to minor_axis but will error if the matrix isn't in either row-major or column-major layout.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.other_axis","page":"Matrix layouts","title":"Daf.MatrixLayouts.other_axis","text":"other_axis(axis::Union{Integer,Nothing})::Union{Int8,Nothing}\n\nReturn the other matrix axis (that is, convert between Rows and Columns). If given nothing returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Changing-layout","page":"Matrix layouts","title":"Changing layout","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Daf.MatrixLayouts.relayout!","category":"page"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.relayout!","page":"Matrix layouts","title":"Daf.MatrixLayouts.relayout!","text":"relayout!(matrix::AbstractMatrix)::AbstractMatrix\nrelayout!(matrix::NamedMatrix)::NamedMatrix\nrelayout!(into::AbstractMatrix, from::AbstractMatrix)::AbstractMatrix\nrelayout!(into::AbstractMatrix, from::NamedMatrix)::NamedMatrix\n\nReturn the same matrix data, but in the other memory layout.\n\nSuppose you have a column-major UMIs matrix, whose rows are cells, and columns are genes. Therefore, summing the UMIs of a gene will be fast, but summing the UMIs of a cell will be slow. A transpose (no !) of a matrix is fast; it creates a zero-copy wrapper of the matrix with flipped axes, so its rows will be genes and columns will be cells, but in row-major layout. Therefore, still, summing the UMIs of a gene is fast, and summing the UMIs of a cell is slow.\n\nIn contrast, transpose! (with a !) is slow; it creates a rearranged copy of the data, also returning a matrix whose rows are genes and columns are cells, but this time, in column-major layout. Therefore, in this case summing the UMIs of a gene will be slow, and summing the UMIs of a cell will be fast.\n\nnote: Note\nIt is almost always worthwhile to relayout! a matrix and then perform operations \"with the grain\" of the data, instead of skipping it and performing operations \"against the grain\" of the data. This is because (in Julia at least) the implementation of transpose! is optimized for the task, while the other operations typically don't provide any specific optimizations for working \"against the grain\" of the data. The benefits of a relayout! become even more significant when performing a series of operations (e.g., summing the gene UMIs in each cell, converting gene UMIs to fractions out of these totals, then computing the log base 2 of this fraction).\n\nIf you transpose (no !) the result of transpose! (with a !), you end up with a matrix that appears to be the same as the original (rows are cells and columns are genes), but behaves differently - summing the UMIs of a gene will be slow, and summing the UMIs of a cell is fast. This transpose of transpose! is a common idiom and is basically what relayout! does for you. In addition, relayout! will work for both sparse and dense matrices, and if into is not specified, a similar matrix is allocated automatically for it.\n\nnote: Note\nThe caller is responsible for providing a sensible into matrix (sparse for a sparse from, dense for a non-sparse from). This can be a transposed matrix. If from is a NamedMatrix, then the result will be a NamedMatrix with the same axes. If into is also a NamedMatrix, then its axes must match from.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Ensuring-code-efficiency","page":"Matrix layouts","title":"Ensuring code efficiency","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Daf.MatrixLayouts.check_efficient_action\nDaf.MatrixLayouts.InefficientActionPolicy\nDaf.MatrixLayouts.inefficient_action_policy","category":"page"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.check_efficient_action","page":"Matrix layouts","title":"Daf.MatrixLayouts.check_efficient_action","text":"check_efficient_action(\n    action::AbstractString,\n    axis::Integer,\n    operand::AbstractString,\n    matrix::AbstractMatrix,\n)::Nothing\n\nThis will check whether the action about to be executed for an operand which is matrix works \"with the grain\" of the data, which requires the matrix to be in axis-major layout. If it isn't, then apply the inefficient_action_policy.\n\nIn general, you really want operations to go \"with the grain\" of the data. Unfortunately, Julia (and Python, and R, and matlab) will silently run operations \"against the grain\", which would be painfully slow. A liberal application of this function will help in detecting such slowdowns, without having to resort to profiling the code to isolate the problem.\n\nnote: Note\nThis will not prevent the code from performing \"against the grain\" operations such as selectdim(matrix, Rows, 1) for a column-major matrix, but if you add this check before performing any (series of) operations on a matrix, then you will have a clear indication of whether (and where) such operations occur. You can then consider whether to invoke relayout! on the data, or (for data fetched from Daf), simply query for the other memory layout.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.InefficientActionPolicy","page":"Matrix layouts","title":"Daf.MatrixLayouts.InefficientActionPolicy","text":"The action to take when performing an operation \"against the grain\" of the memory layout of a matrix.\n\nValid values are:\n\nnothing - do nothing special, just execute the code and hope for the best (the default).\n\nWarnPolicy - emit a warning using @warn.\n\nErrorPolicy - abort the program with an error message.\n\n\n\n\n\n","category":"type"},{"location":"matrix_layouts.html#Daf.MatrixLayouts.inefficient_action_policy","page":"Matrix layouts","title":"Daf.MatrixLayouts.inefficient_action_policy","text":"inefficient_action_policy(\n    policy::Union{InefficientActionPolicy,Nothing}\n)::Union{InefficientActionPolicy,Nothing}\n\nSpecify the policy to take when accessing a matrix in an inefficient way. Returns the previous policy.\n\nnote: Note\nThis will affect all the processes @everywhere, not just the current one.\n\n\n\n\n\n","category":"function"},{"location":"matrix_layouts.html#Index","page":"Matrix layouts","title":"Index","text":"","category":"section"},{"location":"matrix_layouts.html","page":"Matrix layouts","title":"Matrix layouts","text":"Pages = [\"matrix_layouts.md\"]","category":"page"},{"location":"copies.html#Copies","page":"Copies","title":"Copies","text":"","category":"section"},{"location":"copies.html","page":"Copies","title":"Copies","text":"Daf.Copies\nDaf.Copies.copy_scalar!\nDaf.Copies.copy_axis!\nDaf.Copies.copy_vector!\nDaf.Copies.copy_matrix!\nDaf.Copies.copy_all!","category":"page"},{"location":"copies.html#Daf.Copies","page":"Copies","title":"Daf.Copies","text":"Copy data between daf data sets.\n\n\n\n\n\n","category":"module"},{"location":"copies.html#Daf.Copies.copy_scalar!","page":"Copies","title":"Daf.Copies.copy_scalar!","text":"function copy_scalar(;\n    into::DafWriter,\n    from::DafReader,\n    name::AbstractString,\n    [rename::Union{AbstractString, Nothing} = nothing,\n    default::Union{StorageScalar, Nothing, UndefInitializer} = undef]\n)::Nothing\n\nCopy a scalar from some DafReader into some DafWriter.\n\nThe scalar is fetched using the name and the default. If rename is specified, store the scalar using this new name. If overwrite (not the default), overwrite an existing scalar in the target.\n\n\n\n\n\n","category":"function"},{"location":"copies.html#Daf.Copies.copy_axis!","page":"Copies","title":"Daf.Copies.copy_axis!","text":"function copy_axis(;\n    into::DafWriter,\n    from::DafReader,\n    name::AbstractString,\n    [rename::Union{AbstractString, Nothing} = nothing,\n    default::Union{Nothing, UndefInitializer} = undef]\n)::Nothing\n\nCopy an axis from some DafReader into some DafWriter.\n\nThe axis is fetched using the name and the default. If rename is specified, store the axis using this name.\n\n\n\n\n\n","category":"function"},{"location":"copies.html#Daf.Copies.copy_vector!","page":"Copies","title":"Daf.Copies.copy_vector!","text":"function copy_vector(;\n    into::DafWriter,\n    from::DafReader,\n    axis::AbstractString,\n    name::AbstractString,\n    [reaxis::Union{AbstractString, Nothing} = nothing,\n    rename::Union{AbstractString, Nothing} = nothing,\n    default::Union{StorageScalar, StorageVector, Nothing, UndefInitializer} = undef,\n    overwrite::Bool = false]\n)::Nothing\n\nCopy a vector from some DafReader into some DafWriter.\n\nThe vector is fetched using the axis, name and the default. If reaxis is specified, store the vector using this axis. If rename is specified, store the vector using this name. If overwrite (not the default), overwrite an existing vector in the target.\n\nThis requires the axis of one data set is the same, or is a subset of, the other. If the target axis contains entries that do not exist in the source, then empty must be specified to fill the missing values. If the source axis contains entries that do not exist in the target, they are discarded.\n\n\n\n\n\n","category":"function"},{"location":"copies.html#Daf.Copies.copy_matrix!","page":"Copies","title":"Daf.Copies.copy_matrix!","text":"function copy_matrix(;\n    into::DafWriter,\n    from::DafReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    [rows_reaxis::Union{AbstractString, Nothing} = nothing,\n    columns_reaxis::Union{AbstractString, Nothing} = nothing,\n    rename::Union{AbstractString, Nothing} = nothing,\n    default::Union{StorageScalar, StorageVector, Nothing, UndefInitializer} = undef,\n    empty::Union{StorageScalar, Nothing} = nothing,\n    relayout::Bool = true,\n    overwrite::Bool = false]\n)::Nothing\n\nCopy a matrix from some DafReader into some DafWriter.\n\nThe matrix is fetched using the rows_axis, columns_axis, name, relayout and the default. If rows_reaxis and/or columns_reaxis are specified, store the vector using these axes. If rename is specified, store the matrix using this name. If overwrite (not the default), overwrite an existing matrix in the target. The matrix is stored with the same relayout.\n\nThis requires each axis of one data set is the same, or is a subset of, the other. If a target axis contains entries that do not exist in the source, then empty must be specified to fill the missing values. If a source axis contains entries that do not exist in the target, they are discarded.\n\n\n\n\n\n","category":"function"},{"location":"copies.html#Daf.Copies.copy_all!","page":"Copies","title":"Daf.Copies.copy_all!","text":"copy_all!(;\n    into::DafWriter,\n    from::DafReader\n    [overwrite::Bool = false,\n    relayout::Bool = true]\n)::Nothing\n\nCopy all the content of a DafReader into a DafWriter. If overwrite, this will overwrite existing data in the target. If relayout, matrices will be stored in the target both layouts, regardless of how they were stored in the source.\n\nThis will copy missing axes from the source to the target, but will not overwrite existing axes, regardless of the value of overwrite. An axis that exists in the target must be identical to, or be a subset of, the same axis in the source.\n\n\n\n\n\n","category":"function"},{"location":"copies.html#Index","page":"Copies","title":"Index","text":"","category":"section"},{"location":"copies.html","page":"Copies","title":"Copies","text":"Pages = [\"copies.md\"]","category":"page"},{"location":"groups.html#Groups","page":"Groups","title":"Groups","text":"","category":"section"},{"location":"groups.html","page":"Groups","title":"Groups","text":"Daf.Groups\nDaf.Groups.get_chained_vector\nDaf.Groups.aggregate_group_vector\nDaf.Groups.count_groups_matrix","category":"page"},{"location":"groups.html#Daf.Groups","page":"Groups","title":"Daf.Groups","text":"A common data pattern is for entries of one axis to be grouped together. When this happens, we can associate with each entry a data property of the group, or we can aggregate a data property of the entries into a data property of the group. For example, if we group cells into types, we can obtain a cell color by looking up the color of the type of each cell; or if each cell has an age, we can compute the mean cell age of each type.\n\nThe following functions implement these lookup and aggregation operations.\n\n\n\n\n\n","category":"module"},{"location":"groups.html#Daf.Groups.get_chained_vector","page":"Groups","title":"Daf.Groups.get_chained_vector","text":"get_chained_vector(\n    daf::DafReader;\n    axis::AbstractString,\n    names::Vector[S],\n    [default::Union{StorageScalar, UndefInitializer} = undef]\n) -> StorageVector where {S <: AbstractString}\n\nGiven an axis and a series of names properties, expect each property value to be a string, used to lookup its value in a property axis of the same name, until the last property that is actually returned. For example, if the axis is cell and the names are [\"batch\", \"donor\", \"sex\"], then fetch the sex of the donor of the batch of each cell.\n\nThe group axis is assumed to have the same name as the named property (e.g., there would be batch and donor axes). It is also possible to have the property name begin with the axis name followed by a .suffix, for example, fetching [\"type.manual\", \"color\"] will fetch the color from the type axis, based on the value of the type.manual of each cell.\n\nIf, at any place along the chain, the group property value is the empty string, then default must be specified, and will be used for the final result.\n\n\n\n\n\n","category":"function"},{"location":"groups.html#Daf.Groups.aggregate_group_vector","page":"Groups","title":"Daf.Groups.aggregate_group_vector","text":"function aggregate_group_vector(\n    aggregate::Function,\n    daf::DafReader;\n    axis::AbstractString,\n    name::AbstractString,\n    group::AbstractString,\n    group_axis::Union{AbstractString, Nothing} = nothing,\n    default::Union{StorageScalar, UndefInitializer} = undef,\n)::NamedArray\n\nGiven an axis of the daf data (e.g., cell), a name vector property of this axis (e.g., age) and a group vector property of this axis (e.g., type), whose value is the name of an entry of a group axis, then return a vector assigning a value for each entry of the group axis, which is the aggregate of the values of all the original axis entries grouped into that entry (e.g., the mean age of the cells in each type).\n\nBy default, the group_axis is assumed to have the same name as the group property (e.g., there would be a type property per cell, and a type axis). It is possible to override this by specifying an explicit group_axis if the actual name is different.\n\nThe group property must have a string element type. An empty string means that the entry belongs to no group (e.g., we don't have a type assignment for some cell), so its value will not be aggregated into any group. In addition, a group may be empty (e.g., no cell is assigned to some type). In this case, default must be specified, and is used for the empty groups.\n\n\n\n\n\n","category":"function"},{"location":"groups.html#Daf.Groups.count_groups_matrix","page":"Groups","title":"Daf.Groups.count_groups_matrix","text":"function count_groups_matrix(\n    daf::DafReader,\n    axis::AbstractString,\n    rows_names::Vector{R},\n    columns_names::Vector{C};\n    type::Type = UInt32,\n    rows_default::Union{StorageScalar, Nothing},\n    columns_default::Union{StorageScalar, Nothing},\n)::NamedMatrix\n\nGiven an axis of the daf data (e.g., cell), fetch two chained vector properties for it using get_chained_vector, and generate a matrix where each entry is the number of instances which have each specific combination of the values. For example, if axis is cell, rows_names is [\"batch\", \"age\"], and columns_names is [\"type\", \"color\"], then the matrix will have the different ages as rows, different colors as columns, and each entry will count the number of cells with a specific age and a specific color.\n\nIf there exists an axis with the same name as the final row and/or column name, it is used to determine the set of valid values and their order. Otherwise, the entries are sorted in ascending order.\n\nBy default, the data type of the matrix is UInt32, which is a reasonable trade-off between expressiveness (up to 4G) and size (only 4 bytes per entry). You can override this using the type parameter.\n\nnote: Note\nThe typically the chained value type is a string; in this case, entries with an empty string values (ungrouped entries) are not counted. However, the values can also be numeric. In either case, it is expected that the set of actually present values will be small, otherwise the resulting matrix will be very large.\n\n\n\n\n\n","category":"function"},{"location":"groups.html#Index","page":"Groups","title":"Index","text":"","category":"section"},{"location":"groups.html","page":"Groups","title":"Groups","text":"Pages = [\"groups.md\"]","category":"page"},{"location":"parse_queries.html#Queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries","page":"Queries","title":"Daf.ParseQueries","text":"Daf provides a query language that allows for convenient extraction of data from the Storage. This isn't a \"beautiful\" query language, but it is terse, consistent, and reasonably flexible.\n\nWe use an operator precedence parser for queries. That is, one can think of a query as an expression, using specific operators that combine into the overall query expression. For example, the query cell @ batch can be thought of as the expression @(\"cell\", \"batch\") which means \"lookup the value of the property batch for each entry of the cell axis\".\n\nWe separately describe queries that produce matrix data (MatrixQuery), vector data (VectorQuery), and scalar data (ScalarQuery).\n\nWhen parsing a query, we will will properly encode escaped characters, treat any #...<LineBreak> characters sequence as white space, and also condense all consecutive white space characters into a single space (which will convert the query string to a single line). This allows using arbitrary comments, white space and line breaks in complex queries, and also allows error messages to visually refer to the part of the query that triggered them, without having to deal with thorny issues of visually indicating messages inside multi-line query strings. This comes at the cost that the error messages refer to the one-line version of the query string, instead of the original.\n\n\n\n\n\n","category":"module"},{"location":"parse_queries.html#Queries-syntax","page":"Queries","title":"Queries syntax","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.QueryOperators\nDaf.ParseQueries.QueryOperator\nDaf.ParseQueries.QueryOperation\nDaf.ParseQueries.QueryToken\nDaf.ParseQueries.QueryExpression\nDaf.ParseQueries.QueryContext","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.QueryOperators","page":"Queries","title":"Daf.ParseQueries.QueryOperators","text":"The operators that can be used in a Daf query.\n\nOperator Associativity Precedence Description\n%> Left 0 Reduction operation (matrix to vector, vector to scalar), e.g., cell, gene @ UMIs %> Sum\n% Right 1 Element-wise operation (e.g., cell, gene @ UMIs % Log)\n@ Right 2 Lookup (e.g., cell, gene @ UMIs)\n; Right 3 Operation separator (e.g., Log; base = 2)\n, Right 3 1. Axes separator (e.g., cell, gene @ UMIs)\n  3 2. Parameter separator (e.g., Log; base = 2, eps = 1)\n& Right 4 AND filter (e.g., gene & marker)\n| Right 4 OR filter (e.g., gene & marker | noisy)\n^ Right 4 XOR filter (e.g., gene & marker ^ noisy)\n< Right 5 Less than (e.g., batch : age < 1)\n<=, ≤ Right 5 Less or equal (e.g., batch : age <= 1)\n!=, ≠ Right 5 Not equal (e.g., batch : age != 1)\n= Right 5 1. Is equal (e.g., batch : age = 1)\n   2. Select axis entry (e.g., cell, gene = FOX1 @ UMIs)\n   3. Parameter assignment (e.g., Log; base = 2)\n>=, ≥ Right 5 Greater or equal (e.g., batch : age >= 1)\n> Right 5 Greater than (e.g., batch : age > 1)\n!~, ≁ Right 5 Not match (e.g., gene !~ MT-.\\*\n~ Right 5 1. Match (e.g., gene ~ MT-.\\*)\n   2. Invert mask (prefix; e.g., gene & ~noisy)\n? Right 5 Chained property default (e.g., cell : metacell : color ? black)\n: Right 6 Chained property lookup (e.g., batch : age)\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.QueryOperator","page":"Queries","title":"Daf.ParseQueries.QueryOperator","text":"QueryOperator = Operator{QueryOperators}\n\nA description of one of the QueryOperators.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.QueryOperation","page":"Queries","title":"Daf.ParseQueries.QueryOperation","text":"QueryOperation = Operation{QueryOperators}\n\nA non-leaf node in a QueryExpression tree.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.QueryToken","page":"Queries","title":"Daf.ParseQueries.QueryToken","text":"QueryToken = Token{QueryOperators}\n\nA leaf node in a QueryExpression tree.\n\nThis will capture any sequence of safe or escaped characters.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.QueryExpression","page":"Queries","title":"Daf.ParseQueries.QueryExpression","text":"QueryExpression = Expression{QueryOperators}\n\nAn expression tree for a Daf query.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.QueryContext","page":"Queries","title":"Daf.ParseQueries.QueryContext","text":"QueryContext = Context{QueryOperators}\n\nContext for reporting errors while parsing a query.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Matrix-queries","page":"Queries","title":"Matrix queries","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.parse_matrix_query\nDaf.ParseQueries.MatrixQuery\nDaf.ParseQueries.MatrixPropertyLookup\nDaf.ParseQueries.MatrixAxes","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.parse_matrix_query","page":"Queries","title":"Daf.ParseQueries.parse_matrix_query","text":"parse_matrix_query(query_string::AbstractString)::MatrixQuery\n\nParse a MatrixQuery from a query string.\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixQuery","page":"Queries","title":"Daf.ParseQueries.MatrixQuery","text":"MatrixQuery = MatrixPropertyLookup ( % EltwiseOperation )*\n\nA query that returns matrix data.\n\nThere's only one variant of this: looking up a matrix property and optionally passing it through a sequence of element-wise operations.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixPropertyLookup","page":"Queries","title":"Daf.ParseQueries.MatrixPropertyLookup","text":"MatrixPropertyLookup = MatrixAxes @ QueryToken(property name)\n\nLookup a matrix property (that is, a property that gives a value to each combination of entries of two axes).\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixAxes","page":"Queries","title":"Daf.ParseQueries.MatrixAxes","text":"MatrixAxes = FilteredAxis , FilteredAxis\n\n(Possibly filtered) axes of matrix to lookup a property for.\n\nThe first axis specifies the matrix rows, the second axis specifies the matrix columns.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Vector-queries","page":"Queries","title":"Vector queries","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.parse_vector_query\nDaf.ParseQueries.VectorQuery\nDaf.ParseQueries.VectorDataLookup\nDaf.ParseQueries.VectorPropertyLookup\nDaf.ParseQueries.MatrixSliceLookup\nDaf.ParseQueries.MatrixSliceAxes\nDaf.ParseQueries.ReduceMatrixQuery","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.parse_vector_query","page":"Queries","title":"Daf.ParseQueries.parse_vector_query","text":"parse_vector_query(query_string::AbstractString)::VectorQuery\n\nParse a VectorQuery from a query string.\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Daf.ParseQueries.VectorQuery","page":"Queries","title":"Daf.ParseQueries.VectorQuery","text":"VectorQuery = VectorDataLookup ( % EltwiseOperation )*\n\nA query that returns vector data. This looks up some vector data and optionally applies a series of element-wise operations to it.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.VectorDataLookup","page":"Queries","title":"Daf.ParseQueries.VectorDataLookup","text":"VectorDataLookup = VectorPropertyLookup | MatrixSliceLookup | ReduceMatrixQuery\n\nLookup vector data. This can be looking up a vector property, looking up a slice of a matrix property, or reducing the results of matrix query to a vector.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.VectorPropertyLookup","page":"Queries","title":"Daf.ParseQueries.VectorPropertyLookup","text":"VectorPropertyLookup = FilteredAxis @ AxisLookup\n\nLookup a vector property (that is, a property that gives a value to each entry of an axis).\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixSliceLookup","page":"Queries","title":"Daf.ParseQueries.MatrixSliceLookup","text":"MatrixSliceLookup = MatrixSliceAxes @ QueryToken(property name)\n\nLookup a vector slice of a matrix property.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixSliceAxes","page":"Queries","title":"Daf.ParseQueries.MatrixSliceAxes","text":"MatrixSliceAxes = FilteredAxis , AxisEntry\n\n(Possibly filtered) axes of a slice of a matrix to lookup a property for.\n\nThe first axis specifies the result entries, and the second specifies the specific entry of an axis to slice.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.ReduceMatrixQuery","page":"Queries","title":"Daf.ParseQueries.ReduceMatrixQuery","text":"ReduceMatrixQuery = MatrixQuery %> ReductionOperation\n\nQuery for matrix data and reduce it to a vector.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Scalar-queries","page":"Queries","title":"Scalar queries","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.parse_scalar_query\nDaf.ParseQueries.ScalarQuery\nDaf.ParseQueries.ScalarDataLookup\nDaf.ParseQueries.ScalarPropertyLookup\nDaf.ParseQueries.ReduceVectorQuery\nDaf.ParseQueries.VectorEntryLookup\nDaf.ParseQueries.MatrixEntryLookup\nDaf.ParseQueries.MatrixEntryAxes","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.parse_scalar_query","page":"Queries","title":"Daf.ParseQueries.parse_scalar_query","text":"parse_scalar_query(query_string::AbstractString)::ScalarQuery\n\nParse a ScalarQuery from a query string.\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Daf.ParseQueries.ScalarQuery","page":"Queries","title":"Daf.ParseQueries.ScalarQuery","text":"ScalarQuery = ScalarDataLookup ( % EltwiseOperation )*\n\nA query that returns scalar data.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.ScalarDataLookup","page":"Queries","title":"Daf.ParseQueries.ScalarDataLookup","text":"ScalarDataLookup = ScalarPropertyLookup | ReduceVectorQuery | VectorEntryLookup | MatrixEntryLookup\n\nLookup scalar data.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.ScalarPropertyLookup","page":"Queries","title":"Daf.ParseQueries.ScalarPropertyLookup","text":"ScalarPropertyLookup = QueryToken(property name)\n\nLookup a scalar property.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.ReduceVectorQuery","page":"Queries","title":"Daf.ParseQueries.ReduceVectorQuery","text":"ReduceVectorQuery = VectorQuery %> ReductionOperation\n\nQuery for vector data and reduce it to a scalar. The vector query may itself be a reduction of a matrix to a vector, allowing reducing a matrix to a scalar (in two reduction steps).\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.VectorEntryLookup","page":"Queries","title":"Daf.ParseQueries.VectorEntryLookup","text":"VectorEntryLookup = AxisEntry @ AxisLookup\n\nLookup an entry of a vector property.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixEntryLookup","page":"Queries","title":"Daf.ParseQueries.MatrixEntryLookup","text":"MatrixEntryLookup = MatrixEntryAxes @ QueryToken(property name)\n\nLookup an entry of a matrix property.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.MatrixEntryAxes","page":"Queries","title":"Daf.ParseQueries.MatrixEntryAxes","text":"MatrixEntryAxes = AxisEntry , AxisEntry\n\nLocate a single entry of both axes of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Filtering-axes","page":"Queries","title":"Filtering axes","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.FilteredAxis\nDaf.ParseQueries.AxisFilter\nDaf.ParseQueries.FilterOperator\nDaf.ParseQueries.AxisLookup","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.FilteredAxis","page":"Queries","title":"Daf.ParseQueries.FilteredAxis","text":"FilteredAxis = QueryToken(axis name) AxisFilter*\n\n(Possibly filtered) axis to lookup a property for.\n\nBy default, all the axis entries will be used. Applying a filter will restrict the results just to the axis entries that match the result of the filter.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.AxisFilter","page":"Queries","title":"Daf.ParseQueries.AxisFilter","text":"AxisFilter = FilterOperator AxisLookup\n\nA filter to apply to an axis.\n\nBy default we fetch results for each entry of each axis. We can restrict the set of entries we fetch results for by applying filters. Each filter applies a Boolean mask to the set of entries we'll return results for. Filters are applied in a strict left to right order. Each filter can restrict the set of entries (&, AND), increase it (|, OR) or flip entries (^, XOR). For example, gene & noisy | lateral & ~ marker will start with all the genes, restrict the set to just the noisy genes, increase the set to also include lateral genes, and finally decrease the set to exclude marker genes. That is, it will return the set of non-marker genes that are also either noisy or lateral.\n\nIf the AxisLookup does not specify a PropertyComparison, and the looked up property does not have Boolean values, then the values are converted to Boolean by comparing them with zero (for numeric properties) or the empty string (for string properties).\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.FilterOperator","page":"Queries","title":"Daf.ParseQueries.FilterOperator","text":"FilterOperator = & | | | ^\n\nA Boolean operator for updating the mask of a filter.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.AxisLookup","page":"Queries","title":"Daf.ParseQueries.AxisLookup","text":"AxisLookup = ~ PropertyLookup | PropertyLookup PropertyComparison?\n\nLookup some value for each entry of an axis.\n\nThis can simply lookup the value of some property of the axis, e.g., batch : age. In addition, we allow extra features for dealing with Boolean masks. First, if looking up a Boolean property, then prefixing it with a ~ will invert the result, e.g., ~ marker. Second, when looking up a non-Boolean property, it is possible to convert it into Boolean values by comparing it with a constant value, e.g., batch : age > 1. This allows us to use the result as a mask, e.g., when filtering which entries of an axis we want to fetch results for.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Slicing-axes","page":"Queries","title":"Slicing axes","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.AxisEntry","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.AxisEntry","page":"Queries","title":"Daf.ParseQueries.AxisEntry","text":"AxisEntry = QueryToken(axis name) = QueryToken(entry name)\n\nSlice a single entry from an axis.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Looking-up-properties","page":"Queries","title":"Looking up properties","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.PropertyLookup\nDaf.ParseQueries.PropertyComparison\nDaf.ParseQueries.ComparisonOperator","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.PropertyLookup","page":"Queries","title":"Daf.ParseQueries.PropertyLookup","text":"PropertyLookup = QueryToken(property name) ( : QueryToken(property name) )*\n\nLookup the value of some property for a single axis (for vector data) or a pair of axes (for matrix data).\n\nThis is typically just the name of the property to lookup. However, we commonly find that a property of one axis contains names of entries in another axis. For example, we may have a batch property per cell, and an age property per batch. In such cases, we allow a chained lookup of the color of the type of each cell by writing batch : age. The chain can be as long as necessary (e.g., batch : donor : sex).\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.PropertyComparison","page":"Queries","title":"Daf.ParseQueries.PropertyComparison","text":"PropertyComparison = ComparisonOperator QueryToken(property value)\n\nCompare a (non-Boolean) property to a constant value.\n\nThis is used to convert any set of non-Boolean property values for the axis entries into a Boolean mask which we can then use to filter the axis entries, e.g., > 1 will create a mask of all the entries whose value is larger than one.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Daf.ParseQueries.ComparisonOperator","page":"Queries","title":"Daf.ParseQueries.ComparisonOperator","text":"ComparisonOperator = < | <= | ≤ | = | != | ≠ | >= | ≥ | > | ~ | !~ | ≁ | ?\n\nHow to compare a each value of a property with some constant value to generate a filter mask.\n\nThe ? operator is special. Instead of comparing the values, it replaces missing values with a default values. Normally, when using a chained PropertyLookup, it is an error if some entries hold an empty value. The ? operator allows for such cases by using a default value for the end result. For example, cell : metacell : type : color will fail with an error if a specific cell has a metacell value \"\". However,  cell : metacell : type : color ? black will return a value of black for such cells instead.\n\nnote: Note\nFor matching (using ~ or !~), you will have to escape any special characters used in regexp; for example, you will need to write raw\"gene ~ RP\\[LS\\].\\*\" to match all the ribosomal gene names.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Query-operations","page":"Queries","title":"Query operations","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.parse_eltwise_operation\nDaf.ParseQueries.parse_reduction_operation\nDaf.ParseQueries.ParameterAssignment","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.parse_eltwise_operation","page":"Queries","title":"Daf.ParseQueries.parse_eltwise_operation","text":"EltwiseOperation = QueryToken(EltwiseOperation) ( ; ParameterAssignment ( , ParameterAssignment )* )?\n\nParse a EltwiseOperation.\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Daf.ParseQueries.parse_reduction_operation","page":"Queries","title":"Daf.ParseQueries.parse_reduction_operation","text":"ReductionOperation = QueryToken(ReductionOperation) ( ; ParameterAssignment ( , ParameterAssignment )* )?\n\nParse a ReductionOperation. This will reduce a vector to a scalar, or each column of a matrix to a single value (that is, a matrix to a vector).\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Daf.ParseQueries.ParameterAssignment","page":"Queries","title":"Daf.ParseQueries.ParameterAssignment","text":"ParameterAssignment = QueryToken(parameter name) = QueryToken(parameter value)\n\nstruct ParameterAssignment\n    assignment::QueryOperation\nend\n\nAssignment of a value to a single parameter of an element-wise or reduction operation. This is provided to the constructors of EltwiseOperations and ReductionOperations. The constructors will convert the string parameter value to the appropriate parameter type, and will generate error messages in context if the value is invalid.\n\n\n\n\n\n","category":"type"},{"location":"parse_queries.html#Canonical-format","page":"Queries","title":"Canonical format","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Daf.ParseQueries.canonical","category":"page"},{"location":"parse_queries.html#Daf.ParseQueries.canonical","page":"Queries","title":"Daf.ParseQueries.canonical","text":"function canonical(query::Union{MatrixQuery, VectorQuery, ScalarQuery})::String\n\nReturn a canonical form for a query. This strips away any comments, uses a standard white space policy between tokens, and even reorders AxisFilters in a FilteredAxis where possible, so that if two queries are \"the same\", they will have the same canonical form.\n\n\n\n\n\n","category":"function"},{"location":"parse_queries.html#Index","page":"Queries","title":"Index","text":"","category":"section"},{"location":"parse_queries.html","page":"Queries","title":"Queries","text":"Pages = [\"parse_queries.md\"]","category":"page"},{"location":"data_queries.html#Data-Queries","page":"Data Queries","title":"Data Queries","text":"","category":"section"},{"location":"data_queries.html","page":"Data Queries","title":"Data Queries","text":"Daf.DataQueries","category":"page"},{"location":"data_queries.html#Daf.DataQueries","page":"Data Queries","title":"Daf.DataQueries","text":"Compute queries on daf data.\n\n\n\n\n\n","category":"module"},{"location":"data_queries.html","page":"Data Queries","title":"Data Queries","text":"Daf.DataQueries.scalar_query\nDaf.DataQueries.vector_query\nDaf.DataQueries.matrix_query\nDaf.DataQueries.empty_cache!","category":"page"},{"location":"data_queries.html#Daf.DataQueries.scalar_query","page":"Data Queries","title":"Daf.DataQueries.scalar_query","text":"scalar_query(daf::DafReader, query::AbstractString)::Union{StorageScalar, Nothing}\n\nQuery daf for some scalar results. See ScalarQuery for the possible queries that return scalar results.\n\nThe query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can empty_cache! to release it.\n\n\n\n\n\n","category":"function"},{"location":"data_queries.html#Daf.DataQueries.vector_query","page":"Data Queries","title":"Daf.DataQueries.vector_query","text":"vector_query(daf::DafReader, query::AbstractString)::Union{NamedVector, Nothing}\n\nQuery daf for some vector results. See VectorQuery for the possible queries that return vector results. The names of the results are the names of the axis entries. This is especially useful when the query applies a mask to the axis. Will return nothing if any of the masks is empty.\n\nThe query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can empty_cache! to release it.\n\n\n\n\n\n","category":"function"},{"location":"data_queries.html#Daf.DataQueries.matrix_query","page":"Data Queries","title":"Daf.DataQueries.matrix_query","text":"matrix_query(daf::DafReader, query::AbstractString)::Union{NamedMatrix, Nothing}\n\nQuery daf for some matrix results. See MatrixQuery for the possible queries that return matrix results. The names of the axes of the result are the names of the axis entries. This is especially useful when the query applies masks to the axes. Will return nothing if any of the masks is empty.\n\nThe query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can empty_cache! to release it.\n\n\n\n\n\n","category":"function"},{"location":"data_queries.html#Daf.DataQueries.empty_cache!","page":"Data Queries","title":"Daf.DataQueries.empty_cache!","text":"empty_cache!(daf::DafReader)::Nothing\n\nEmpty the cached computed results. This includes computed query results, as well as any relayout matrices that couldn't be stored in the daf storage itself.\n\nThis might be needed if caching consumes too much memory. To see what (if anything) is cached, look at the results of description.\n\n\n\n\n\n","category":"function"},{"location":"data_queries.html#Index","page":"Data Queries","title":"Index","text":"","category":"section"},{"location":"data_queries.html","page":"Data Queries","title":"Data Queries","text":"Pages = [\"data_queries.md\"]","category":"page"},{"location":"memory_format.html#Memory-Format","page":"Memory Format","title":"Memory Format","text":"","category":"section"},{"location":"memory_format.html","page":"Memory Format","title":"Memory Format","text":"Daf.MemoryFormat\nDaf.MemoryFormat.MemoryDaf","category":"page"},{"location":"memory_format.html#Daf.MemoryFormat","page":"Memory Format","title":"Daf.MemoryFormat","text":"In-memory storage Daf storage format.\n\n\n\n\n\n","category":"module"},{"location":"memory_format.html#Daf.MemoryFormat.MemoryDaf","page":"Memory Format","title":"Daf.MemoryFormat.MemoryDaf","text":"MemoryDaf(name::String)\n\nSimple in-memory storage.\n\nThis just keeps everything in-memory, similarly to the way an AnnData object works; that is, this is a lightweight object that just keeps references to the data it is given.\n\nThis is the \"default\" storage type you should use, unless you need to persist the data on the disk.\n\n\n\n\n\n","category":"type"},{"location":"memory_format.html#Index","page":"Memory Format","title":"Index","text":"","category":"section"},{"location":"memory_format.html","page":"Memory Format","title":"Memory Format","text":"Pages = [\"memory_format.md\"]","category":"page"},{"location":"operations.html#Query-operations","page":"Query operations","title":"Query operations","text":"","category":"section"},{"location":"operations.html","page":"Query operations","title":"Query operations","text":"Daf.Operations","category":"page"},{"location":"operations.html#Daf.Operations","page":"Query operations","title":"Daf.Operations","text":"A Daf query can use operations to process the data: EltwiseOperations that preserve the shape of the data, and ReductionOperations that reduce a matrix to a vector, or a vector to a scalar.\n\n\n\n\n\n","category":"module"},{"location":"operations.html#Element-wise-operations","page":"Query operations","title":"Element-wise operations","text":"","category":"section"},{"location":"operations.html","page":"Query operations","title":"Query operations","text":"Daf.Operations.Abs\nDaf.Operations.Log\nDaf.Operations.Round","category":"page"},{"location":"operations.html#Daf.Operations.Abs","page":"Query operations","title":"Daf.Operations.Abs","text":"Element-wise operation that converts every element to its absolute value.\n\n\n\n\n\n","category":"type"},{"location":"operations.html#Daf.Operations.Log","page":"Query operations","title":"Daf.Operations.Log","text":"Element-wise operation that converts every element to its logarithm.\n\nParameters:\n\nbase - The base of the logarithm. By default uses e (that is, computes the natural logarithm), which isn't convenient, but is the standard.\n\neps - Added to the input before computing the logarithm, to handle zero input data. By default is zero.\n\n\n\n\n\n","category":"type"},{"location":"operations.html#Daf.Operations.Round","page":"Query operations","title":"Daf.Operations.Round","text":"Element-wise operation that converts every element to the nearest integer value.\n\n\n\n\n\n","category":"type"},{"location":"operations.html#Reduction-operations","page":"Query operations","title":"Reduction operations","text":"","category":"section"},{"location":"operations.html","page":"Query operations","title":"Query operations","text":"Daf.Operations.Max\nDaf.Operations.Sum","category":"page"},{"location":"operations.html#Daf.Operations.Max","page":"Query operations","title":"Daf.Operations.Max","text":"Reduction operation that returns the maximal element.\n\n\n\n\n\n","category":"type"},{"location":"operations.html#Daf.Operations.Sum","page":"Query operations","title":"Daf.Operations.Sum","text":"Reduction operation that sums elements.\n\n\n\n\n\n","category":"type"},{"location":"operations.html#Support-functions","page":"Query operations","title":"Support functions","text":"","category":"section"},{"location":"operations.html","page":"Query operations","title":"Query operations","text":"Daf.Operations.parse_parameter\nDaf.Operations.parse_number_assignment\nDaf.Operations.parse_dtype_assignment\nDaf.Operations.invalid_parameter_value\nDaf.Operations.float_dtype_for\nDaf.Operations.int_dtype_for","category":"page"},{"location":"operations.html#Daf.Operations.parse_parameter","page":"Query operations","title":"Daf.Operations.parse_parameter","text":"function parse_parameter(\n    parse_assignment::Function,\n    context::QueryContext,\n    parameters_assignments::Dict{String, QueryOperation},\n    parameter_name::AbstractString,\n    default::Any,\n)::Any\n\nParse an operation parameter.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Daf.Operations.parse_number_assignment","page":"Query operations","title":"Daf.Operations.parse_number_assignment","text":"function parse_number_assignment(\n    context::QueryContext,\n    parameter_assignment::QueryOperation,\n    type::Type{T},\n)::T where {T <: Number}\n\nParse a numeric operation parameter.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Daf.Operations.parse_dtype_assignment","page":"Query operations","title":"Daf.Operations.parse_dtype_assignment","text":"parse_dtype_assignment(\n    context::QueryContext,\n    parameter_assignment::QueryOperation\n)::Union{Type, Nothing}\n\nParse the dtype operation parameter.\n\nValid names are {B,b}ool, {UI,ui,I,i}nt{8,16,32,64} and {F,f}loat{32,64}.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Daf.Operations.invalid_parameter_value","page":"Query operations","title":"Daf.Operations.invalid_parameter_value","text":"invalid_parameter_value(\n    context::QueryContext,\n    parameter_assignment::QueryOperation,\n    must_be::AbstractString\n)::Nothing\n\nComplain that an operation parameter is not valid.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Daf.Operations.float_dtype_for","page":"Query operations","title":"Daf.Operations.float_dtype_for","text":"float_dtype_for(element_type::Type)::Type\n\nGiven an input element_type, return the data type to use for the result of an operation that always produces floating point values (e.g., Log). If dtype isn't (the default) nothing, it is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Daf.Operations.int_dtype_for","page":"Query operations","title":"Daf.Operations.int_dtype_for","text":"int_dtype_for(element_type::Type[, dtype::Union{Type, Nothing} = nothing])::Type\n\nGiven an input element_type, return the data type to use for the result of an operation that always produces integer values (e.g., Round). If dtype isn't (the default) nothing, it is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Index","page":"Query operations","title":"Index","text":"","category":"section"},{"location":"operations.html","page":"Query operations","title":"Query operations","text":"Pages = [\"operations.md\"]","category":"page"},{"location":"views.html#Views","page":"Views","title":"Views","text":"","category":"section"},{"location":"views.html","page":"Views","title":"Views","text":"Daf.Views\nDaf.Views.DafView\nDaf.Views.viewer\nDaf.Views.ALL_SCALARS\nDaf.Views.ALL_AXES\nDaf.Views.ALL_VECTORS\nDaf.Views.ALL_MATRICES","category":"page"},{"location":"views.html#Daf.Views","page":"Views","title":"Daf.Views","text":"Create a different view of Daf data using queries. This is a very flexible mechanism which can be used for a variety of use cases. A simple way of using this is to view a subset of the data as a Daf data set. A variant of this also renames the data properties to adapt them to the requirements of some computation. This makes it simpler to create such tools (using fixed, generic property names) and apply them to arbitrary data (with arbitrary specific property names).\n\n\n\n\n\n","category":"module"},{"location":"views.html#Daf.Views.DafView","page":"Views","title":"Daf.Views.DafView","text":"struct DafView(daf::F) <: DafReader where {F <: DafReader}\n\nA read-only wrapper for any DafReader data, which exposes an arbitrary view of it as another DafReader. This isn't typically created manually; instead call viewer.\n\n\n\n\n\n","category":"type"},{"location":"views.html#Daf.Views.viewer","page":"Views","title":"Daf.Views.viewer","text":"viewer(\n    name::AbstractString,\n    daf::DafReader;\n    [scalars::AbstractVector{Pair{String, Union{String, Nothing}}} = [],\n    axes::AbstractVector{Pair{String, Union{String, Nothing}}} = [],\n    vectors::AbstractVector{Pair{Tuple{String, String}, Union{String, Nothing}}} = []]\n    matrices::AbstractVector{Pair{Tuple{String, String, String}, Union{String, Nothing}}} = []]\n)::Union{DafView, ReadOnlyView}\n\nWrap daf data with a read-only DafView. The exposed view is defined by a set of queries applied to the original data. These queries are evaluated only when data is actually accessed. Therefore, creating a view is a relatively cheap operation.\n\nQueries are listed separately for scalars, axes, vector and matrix properties, as follows:\n\nScalars are specified as a list of pairs (similar to initializing a Dict). The order of the pairs matter (last one wins). If the key is \"*\", then it is replaced by all the names of the scalar properties of the wrapped daf data. If the value is nothing, then the scalar will not be exposed by the view. If the value is \"=\", then the scalar will be exposed with the same value as in the original daf data. Otherwise the value is any valid scalar_query.\n\nThat is, saying \"*\" => \"=\" will expose all the original daf data scalars from the view. Following this by saying \"version\" => nothing will hide the version from the view. Add \"total_umis\" => \"cell, gene @ UMIs %> Sum %> Sum\" to expose a total_umis scalar containing the total sum of all UMIs of all genes in all cells, etc.\n\nAxes are specified similarly, except that the value should be a vector_query instead of a scalar_query. This query should be for the names of the entries of the axis, so a @ name suffix is automatically added to the end of the value.\n\nThat is, writing \"gene\" => \"gene & marker\" will restrict the exposed gene axis to only the marker genes. This ability to restrict a view to a subset of the entries is extremely useful.\n\nVectors are specified similarly, but require a key specifying both an axis and a property name. The axis must be exposed by the view (based on the axes parameter). If the axis is \"*\", it is replaces by all the exposed axis names specified by the axes parameter. Similarly, if the name is \"*\" (e.g., (\"gene\", \"*\")), then  it is replaced by all the vector properties of the axis. Therefore if the key is (\"*\", \"*\"), all vector properties of all the exposed axes will also be exposed; to expose all vector properties of all axes, write axes=[\"*\" => \"=\"], vectors=[(\"*\", \"*\") => \"=\"].\n\nThe value for vectors must be a vector query based on the appropriate axis; a value of \"=\" is again used to expose the property as-is. Since the axis might be specified by a query itself, it is automatically added (including the @ operator) as a prefix for the value; for example, specifying that axes = [\"gene\" => \"gene & marker\"], and then that vectors = [(\"gene\", \"forbidden\") => \"lateral\"], then the view will expose a forbidden vector property for the gene axis, by applying the query gene & marker @ lateral to the original daf data.\n\nThis gets trickier when using a query reducing a matrix to a vector. In these cases, the value should contain a @ but only specify the rows axis, and the columns axis will be added automatically. For example, given the same axes as above, and vectors = [(\"gene\", \"total_umis\") => \"cell @ UMIS %> Sum\"], then the view will expose a total_umis vector property for the gene axis, by applying the query cell, gene & marker @ UMIs %> Sum to the original daf data.\n\nMatrices require a key specifying both axes and a property name. The axes must both be exposed by the view (based on the axes parameter). Again if any or both of the axes are \"*\", they are replaced by all the exposed axes (based on the axes parameter), and likewise if the name is \"*\", it replaced by all the matrix properties of the axes.\n\nThe value for matrices can again be \"=\" to expose the property as is, or the suffix of a matrix query. The full query will have the axes queries appended automatically, similarly to the above. The order of the axes does not matter, so matrices = [(\"gene\", \"cell\", \"UMIs\") => \"=\"] has the same effect as matrices = [(\"cell\", \"gene\", \"UMIs\") => \"=\"].\n\nnote: Note\nAs an optimization, calling viewer with all-empty (default) arguments returns a simple ReadOnlyView, that is, it is equivalent to calling read_only. In this case the name is ignored.\n\n\n\n\n\n","category":"function"},{"location":"views.html#Daf.Views.ALL_SCALARS","page":"Views","title":"Daf.Views.ALL_SCALARS","text":"A pair to use in the scalars parameter of viewer to specify the view exposes all the base data scalars.\n\n\n\n\n\n","category":"constant"},{"location":"views.html#Daf.Views.ALL_AXES","page":"Views","title":"Daf.Views.ALL_AXES","text":"A pair to use in the axes parameter of viewer to specify the view exposes all the base data axes.\n\n\n\n\n\n","category":"constant"},{"location":"views.html#Daf.Views.ALL_VECTORS","page":"Views","title":"Daf.Views.ALL_VECTORS","text":"A pair to use in the vectors parameter of viewer to specify the view exposes all the vectors of the exposed axes.\n\n\n\n\n\n","category":"constant"},{"location":"views.html#Daf.Views.ALL_MATRICES","page":"Views","title":"Daf.Views.ALL_MATRICES","text":"A pair to use in the matrices parameter of viewer to specify the view exposes all the matrices of the exposed axes.\n\n\n\n\n\n","category":"constant"},{"location":"views.html#Index","page":"Views","title":"Index","text":"","category":"section"},{"location":"views.html","page":"Views","title":"Views","text":"Pages = [\"views.md\"]","category":"page"},{"location":"todo.html#TODO","page":"TODO","title":"TODO","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"The following issues are not addressed (yet):","category":"page"},{"location":"todo.html#Basic-functionality","page":"TODO","title":"Basic functionality","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"Aggregation in queries.","category":"page"},{"location":"todo.html#Disk-storage-formats","page":"TODO","title":"Disk storage formats","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"FilesStorage\nHdf5Storage\nAnnDataStorage","category":"page"},{"location":"todo.html#Queries","page":"TODO","title":"Queries","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"Test the operations.\nImplement more operations.","category":"page"},{"location":"todo.html#Functionality","page":"TODO","title":"Functionality","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"concatenate_sparse_vectors!\nconcatenate_sparse_matrices!\nConcatenate along axis","category":"page"},{"location":"todo.html#Tracking","page":"TODO","title":"Tracking","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"Log non-computation functions.\nCollect computations invocations into \"computations\" scalar (JSON blob)?\nRepository: DAG of data sets","category":"page"},{"location":"todo.html#Documentation","page":"TODO","title":"Documentation","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"Add examples and doctests (especially for queries)\nLink to Expression in documentation of Context?\nLink to encode_expression in documentation of Token?\nRename links to QueryToken in documentation of queries?","category":"page"},{"location":"todo.html#Misc","page":"TODO","title":"Misc","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"Make containers thread-safe!!!\n@everywhere for registries","category":"page"},{"location":"todo.html#Performance","page":"TODO","title":"Performance","text":"","category":"section"},{"location":"todo.html","page":"TODO","title":"TODO","text":"More efficient copy of :from_is_subset sparse matrices.\nexpand_sparse_vector\nexpand_sparse_matrix","category":"page"},{"location":"formats.html#Formats","page":"Formats","title":"Formats","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats","category":"page"},{"location":"formats.html#Daf.Formats","page":"Formats","title":"Daf.Formats","text":"The FormatReader and FormatWriter interfaces specify a low-level API for storing Daf data. To extend Daf to support an additional format, create a new implementation of this API.\n\nA storage format object contains some named scalar data, a set of axes (each with a unique name for each entry), and named vector and matrix data based on these axes.\n\nData properties are identified by a unique name given the axes they are based on. That is, there is a separate namespace for scalar properties, vector properties for each specific axis, and matrix properties for each (ordered) pair of axes.\n\nFor matrices, we keep careful track of their MatrixLayouts. Specifically, a storage format only deals with column-major matrices, listed under the rows axis first and the columns axis second. A storage format object may hold two copies of the same matrix, in both possible memory layouts, in which case it will be listed twice, under both axes orders.\n\nIn general, storage format objects are as \"dumb\" as possible, to make it easier to support new storage formats. The required functions implement a glorified key-value repository, with the absolutely minimal necessary logic to deal with the separate property namespaces listed above.\n\nFor clarity of documentation, we split the type hierarchy to DafWriter <: FormatWriter <: DafReader <: FormatReader.\n\nThe functions listed here use the FormatReader for read-only operations and FormatWriter for write operations into a Daf storage. This is a low-level API, not meant to be used from outside the package, and therefore is not re-exported from the top-level Daf namespace.\n\nIn contrast, the functions using DafReader and DafWriter describe the high-level API meant to be used from outside the package, and are re-exported. These functions are listed in the Daf.Data module. These functions provide all the logic common to any storage format, allowing us to keep the format-specific functions as simple as possible.\n\nThat is, when implementing a new Daf storage format, you should write struct MyFormat <: DafWriter, and implement the functions listed here for both FormatReader and FormatWriter.\n\n\n\n\n\n","category":"module"},{"location":"formats.html#Read-API","page":"Formats","title":"Read API","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.DafReader\nDaf.Formats.FormatReader\nDaf.Formats.Internal","category":"page"},{"location":"formats.html#Daf.Formats.DafReader","page":"Formats","title":"Daf.Formats.DafReader","text":"A  high-level abstract interface for read-only access to Daf data.\n\nAll the functions for this type are provided based on the functions required for FormatReader. See the Daf.Data module for their description.\n\n\n\n\n\n","category":"type"},{"location":"formats.html#Daf.Formats.FormatReader","page":"Formats","title":"Daf.Formats.FormatReader","text":"An low-level abstract interface for reading from Daf storage formats.\n\nWe require each storage format to have a .internal::Internal property. This enables all the high-level DafReader functions.\n\nEach storage format must implement the functions listed below for reading from the storage.\n\n\n\n\n\n","category":"type"},{"location":"formats.html#Daf.Formats.Internal","page":"Formats","title":"Daf.Formats.Internal","text":"Internal(name::AbstractString)\n\nInternal data we need to keep in any concrete FormatReader. This has to be available as a .internal data member of the concrete format. This enables all the high-level DafReader and DafWriter functions.\n\nThe constructor will automatically call unique_name to try and make the names unique for improved error messages.\n\n\n\n\n\n","category":"type"},{"location":"formats.html#Description","page":"Formats","title":"Description","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_description_header\nDaf.Formats.format_description_footer","category":"page"},{"location":"formats.html#Daf.Formats.format_description_header","page":"Formats","title":"Daf.Formats.format_description_header","text":"function format_description_header(format::FormatReader, lines::Array{String})::Nothing\n\nAllow a format to amit additional description header lines.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_description_footer","page":"Formats","title":"Daf.Formats.format_description_footer","text":"function format_description_footer(format::FormatReader, lines::Array{String})::Nothing\n\nAllow a format to amit additional description footer lines. If deep, this also emit the description of any data sets nested in this one, if any.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Scalar-properties","page":"Formats","title":"Scalar properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_has_scalar\nDaf.Formats.format_scalar_names\nDaf.Formats.format_get_scalar","category":"page"},{"location":"formats.html#Daf.Formats.format_has_scalar","page":"Formats","title":"Daf.Formats.format_has_scalar","text":"format_has_scalar(format::FormatReader, name::AbstractString)::Bool\n\nCheck whether a scalar property with some name exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_scalar_names","page":"Formats","title":"Daf.Formats.format_scalar_names","text":"format_scalar_names(format::FormatReader)::Set{String}\n\nThe names of the scalar properties in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_get_scalar","page":"Formats","title":"Daf.Formats.format_get_scalar","text":"format_get_scalar(format::FormatReader, name::AbstractString)::StorageScalar\n\nImplement fetching the value of a scalar property with some name in format.\n\nThis trusts the name scalar property exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Data-axes","page":"Formats","title":"Data axes","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_has_axis\nDaf.Formats.format_axis_names\nDaf.Formats.format_get_axis\nDaf.Formats.format_axis_length","category":"page"},{"location":"formats.html#Daf.Formats.format_has_axis","page":"Formats","title":"Daf.Formats.format_has_axis","text":"format_has_axis(format::FormatReader, axis::AbstractString)::Bool\n\nCheck whether some axis exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_axis_names","page":"Formats","title":"Daf.Formats.format_axis_names","text":"format_axis_names(format::FormatReader)::AbstractSet{String}\n\nThe names of the axes of format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_get_axis","page":"Formats","title":"Daf.Formats.format_get_axis","text":"format_get_axis(format::FormatReader, axis::AbstractString)::AbstractVector{String}\n\nImplement fetching the unique names of the entries of some axis of format.\n\nThis trusts the axis exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_axis_length","page":"Formats","title":"Daf.Formats.format_axis_length","text":"format_axis_length(format::FormatReader, axis::AbstractString)::Int64\n\nImplement fetching the number of entries along the axis.\n\nThis trusts the axis exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Vector-properties","page":"Formats","title":"Vector properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_has_vector\nDaf.Formats.format_vector_names\nDaf.Formats.format_get_vector","category":"page"},{"location":"formats.html#Daf.Formats.format_has_vector","page":"Formats","title":"Daf.Formats.format_has_vector","text":"format_has_vector(format::FormatReader, axis::AbstractString, name::AbstractString)::Bool\n\nImplement checking whether a vector property with some name exists for the axis in format.\n\nThis trusts the axis exists in format and that the property name isn't name.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_vector_names","page":"Formats","title":"Daf.Formats.format_vector_names","text":"format_vector_names(format::FormatReader, axis::AbstractString)::Set{String}\n\nImplement fetching the names of the vectors for the axis in format, not including the special name property.\n\nThis trusts the axis exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_get_vector","page":"Formats","title":"Daf.Formats.format_get_vector","text":"format_get_vector(format::FormatReader, axis::AbstractString, name::AbstractString)::StorageVector\n\nImplement fetching the vector property with some name for some axis in format.\n\nThis trusts the axis exists in format, and the name vector property exists for the axis.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Matrix-properties","page":"Formats","title":"Matrix properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_has_matrix\nDaf.Formats.format_matrix_names\nDaf.Formats.format_get_matrix","category":"page"},{"location":"formats.html#Daf.Formats.format_has_matrix","page":"Formats","title":"Daf.Formats.format_has_matrix","text":"format_has_matrix(\n    format::FormatReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n)::Bool\n\nImplement checking whether a matrix property with some name exists for the rows_axis and the columns_axis in format.\n\nThis trusts the rows_axis and the columns_axis exist in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_matrix_names","page":"Formats","title":"Daf.Formats.format_matrix_names","text":"format_matrix_names(\n    format::FormatReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n)::Set{String}\n\nImplement fetching the names of the matrix properties for the rows_axis and columns_axis in format.\n\nThis trusts the rows_axis and columns_axis exist in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_get_matrix","page":"Formats","title":"Daf.Formats.format_get_matrix","text":"format_get_matrix(\n    format::FormatReader,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString\n)::StorageMatrix\n\nImplement fetching the matrix property with some name for some rows_axis and columns_axis in format.\n\nThis trusts the rows_axis and columns_axis exist in format, and the name matrix property exists for them.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Write-API","page":"Formats","title":"Write API","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.DafWriter\nDaf.Formats.FormatWriter","category":"page"},{"location":"formats.html#Daf.Formats.DafWriter","page":"Formats","title":"Daf.Formats.DafWriter","text":"A  high-level abstract interface for write access to Daf data.\n\nAll the functions for this type are provided based on the functions required for FormatWriter. See the Daf.Data module for their description.\n\n\n\n\n\n","category":"type"},{"location":"formats.html#Daf.Formats.FormatWriter","page":"Formats","title":"Daf.Formats.FormatWriter","text":"An abstract interface for writing into Daf storage formats.\n\nEach storage format must implement the functions listed below for writing into the storage.\n\n\n\n\n\n","category":"type"},{"location":"formats.html#Scalar-properties-2","page":"Formats","title":"Scalar properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_set_scalar!\nDaf.Formats.format_delete_scalar!","category":"page"},{"location":"formats.html#Daf.Formats.format_set_scalar!","page":"Formats","title":"Daf.Formats.format_set_scalar!","text":"format_set_scalar!(\n    format::FormatWriter,\n    name::AbstractString,\n    value::StorageScalar,\n)::Nothing\n\nImplement setting the value of a scalar property with some name in format.\n\nThis trusts that the name scalar property does not exist in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_delete_scalar!","page":"Formats","title":"Daf.Formats.format_delete_scalar!","text":"format_delete_scalar!(\n    format::FormatWriter,\n    name::AbstractString;\n    for_set::Bool\n)::Nothing\n\nImplement deleting a scalar property with some name from format. If for_set, this is done just prior to setting the scalar with a different value.\n\nThis trusts that the name scalar property exists in format.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Data-axes-2","page":"Formats","title":"Data axes","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_add_axis!\nDaf.Formats.format_delete_axis!","category":"page"},{"location":"formats.html#Daf.Formats.format_add_axis!","page":"Formats","title":"Daf.Formats.format_add_axis!","text":"format_add_axis!(\n    format::FormatWriter,\n    axis::AbstractString,\n    entries::AbstractVector{String}\n)::Nothing\n\nImplement adding a new axis to format.\n\nThis trusts that the axis does not already exist in format, and that the names of the entries are unique.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_delete_axis!","page":"Formats","title":"Daf.Formats.format_delete_axis!","text":"format_delete_axis!(format::FormatWriter, axis::AbstractString)::Nothing\n\nImplement deleting some axis from format.\n\nThis trusts that the axis exists in format, and that all properties that are based on this axis have already been deleted.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Vector-properties-2","page":"Formats","title":"Vector properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_set_vector!\nDaf.Formats.format_delete_vector!","category":"page"},{"location":"formats.html#Daf.Formats.format_set_vector!","page":"Formats","title":"Daf.Formats.format_set_vector!","text":"format_set_vector!(\n    format::FormatWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    vector::Union{StorageScalar, StorageVector},\n)::Nothing\n\nImplement setting a vector property with some name for some axis in format.\n\nIf the vector specified is actually a StorageScalar, the stored vector is filled with this value.\n\nThis trusts the axis exists in format, that the vector property name isn't \"name\", that it does not exist for the axis, and that the vector has the appropriate length for it.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_delete_vector!","page":"Formats","title":"Daf.Formats.format_delete_vector!","text":"format_delete_vector!(\n    format::FormatWriter,\n    axis::AbstractString,\n    name::AbstractString;\n    for_set::Bool\n)::Nothing\n\nImplement deleting a vector property with some name for some axis from format. If for_set, this is done just prior to setting the vector with a different value.\n\nThis trusts the axis exists in format, that the vector property name isn't name, and that the name vector exists for the axis.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Matrix-properties-2","page":"Formats","title":"Matrix properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_set_matrix!\nDaf.Formats.format_relayout_matrix!\nDaf.Formats.format_delete_matrix!","category":"page"},{"location":"formats.html#Daf.Formats.format_set_matrix!","page":"Formats","title":"Daf.Formats.format_set_matrix!","text":"format_set_matrix!(\n    format::FormatWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    matrix::StorageMatrix,\n)::Nothing\n\nImplement setting the matrix property with some name for some rows_axis and columns_axis in format.\n\nIf the matrix specified is actually a StorageScalar, the stored matrix is filled with this value.\n\nThis trusts the rows_axis and columns_axis exist in format, that the name matrix property does not exist for them, and that the matrix is column-major of the appropriate size for it.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_relayout_matrix!","page":"Formats","title":"Daf.Formats.format_relayout_matrix!","text":"format_relayout_matrix!(\n    format::FormatWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString\n)::Nothing\n\nrelayout! the existing name column-major matrix property for the rows_axis and the columns_axis and store the results as a row-major matrix property (that is, with flipped axes).\n\nThis trusts the rows_axis and columns_axis exist in format, that the name matrix property exists for them, and that it does not exist for the flipped axes.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_delete_matrix!","page":"Formats","title":"Daf.Formats.format_delete_matrix!","text":"format_delete_matrix!(\n    format::FormatWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString;\n    for_set::Bool\n)::Nothing\n\nImplement deleting a matrix property with some name for some rows_axis and columns_axis from format. If for_set, this is done just prior to setting the matrix with a different value.\n\nThis trusts the rows_axis and columns_axis exist in format, and that the name matrix property exists for them.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Creating-properties","page":"Formats","title":"Creating properties","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Daf.Formats.format_empty_dense_vector!\nDaf.Formats.format_empty_sparse_vector!\nDaf.Formats.format_empty_dense_matrix!\nDaf.Formats.format_empty_sparse_matrix!","category":"page"},{"location":"formats.html#Daf.Formats.format_empty_dense_vector!","page":"Formats","title":"Daf.Formats.format_empty_dense_vector!","text":"format_empty_dense_vector!(\n    format::FormatWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n)::DenseVector where {T <: Number}\n\nImplement setting a vector property with some name for some axis in format.\n\nImplement creating an empty dense matrix with some name for some rows_axis and columns_axis in format.\n\nThis trusts the axis exists in format and that the vector property name isn't \"name\", and that it does not exist for the axis.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_empty_sparse_vector!","page":"Formats","title":"Daf.Formats.format_empty_sparse_vector!","text":"format_empty_sparse_vector!(\n    format::FormatWriter,\n    axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n    nnz::Integer,\n    indtype::Type{I},\n)::SparseVector{T, I} where {T <: Number, I <: Integer}\n\nImplement creating an empty dense vector property with some name for some rows_axis and columns_axis in format.\n\nThis trusts the axis exists in format and that the vector property name isn't \"name\", and that it does not exist for the axis.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_empty_dense_matrix!","page":"Formats","title":"Daf.Formats.format_empty_dense_matrix!","text":"format_empty_dense_matrix!(\n    format::FormatWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n)::DenseMatrix{T} where {T <: Number}\n\nImplement creating an empty dense matrix property with some name for some rows_axis and columns_axis in format.\n\nThis trusts the rows_axis and columns_axis exist in format and that the name matrix property does not exist for them.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Daf.Formats.format_empty_sparse_matrix!","page":"Formats","title":"Daf.Formats.format_empty_sparse_matrix!","text":"format_empty_dense_matrix!(\n    format::FormatWriter,\n    rows_axis::AbstractString,\n    columns_axis::AbstractString,\n    name::AbstractString,\n    eltype::Type{T},\n    intdype::Type{I},\n    nnz::Integer,\n)::SparseMatrixCSC{T, I} where {T <: Number, I <: Integer}\n\nImplement creating an empty sparse matrix property with some name for some rows_axis and columns_axis in format.\n\nThis trusts the rows_axis and columns_axis exist in format and that the name matrix property does not exist for them.\n\n\n\n\n\n","category":"function"},{"location":"formats.html#Index","page":"Formats","title":"Index","text":"","category":"section"},{"location":"formats.html","page":"Formats","title":"Formats","text":"Pages = [\"formats.md\"]","category":"page"},{"location":"example_data.html#Example-data","page":"Example data","title":"Example data","text":"","category":"section"},{"location":"example_data.html","page":"Example data","title":"Example data","text":"Daf.ExampleData","category":"page"},{"location":"example_data.html#Daf.ExampleData","page":"Example data","title":"Daf.ExampleData","text":"Example data for doctest tests.\n\n\n\n\n\n","category":"module"},{"location":"example_data.html#Example-Storage","page":"Example data","title":"Example Storage","text":"","category":"section"},{"location":"example_data.html","page":"Example data","title":"Example data","text":"Daf.ExampleData.example_daf","category":"page"},{"location":"example_data.html#Daf.ExampleData.example_daf","page":"Example data","title":"Daf.ExampleData.example_daf","text":"Create an example memory daf to use for doctest tests.\n\n\n\n\n\n","category":"function"},{"location":"example_data.html#Index","page":"Example data","title":"Index","text":"","category":"section"},{"location":"example_data.html","page":"Example data","title":"Example data","text":"Pages = [\"example_data.md\"]","category":"page"},{"location":"read_only.html#Read-only","page":"Read-only","title":"Read-only","text":"","category":"section"},{"location":"read_only.html","page":"Read-only","title":"Read-only","text":"Daf.ReadOnly\nDaf.ReadOnly.ReadOnlyView\nDaf.ReadOnly.read_only","category":"page"},{"location":"read_only.html#Daf.ReadOnly","page":"Read-only","title":"Daf.ReadOnly","text":"Read-only Daf storage format.\n\n\n\n\n\n","category":"module"},{"location":"read_only.html#Daf.ReadOnly.ReadOnlyView","page":"Read-only","title":"Daf.ReadOnly.ReadOnlyView","text":"struct ReadOnlyView <: DafReader ... end\n\nA wrapper for any DafWriter data, protecting it against accidental modification. This isn't typically created manually; instead call read_only.\n\n\n\n\n\n","category":"type"},{"location":"read_only.html#Daf.ReadOnly.read_only","page":"Read-only","title":"Daf.ReadOnly.read_only","text":"read_only(daf::DafReader)::ReadOnlyView\n\nWrap daf with a ReadOnlyView to protect it against accidental modification. If given a read-only daf, return it as-is.\n\n\n\n\n\n","category":"function"},{"location":"read_only.html#Index","page":"Read-only","title":"Index","text":"","category":"section"},{"location":"read_only.html","page":"Read-only","title":"Read-only","text":"Pages = [\"read_only.md\"]","category":"page"},{"location":"index.html#Daf","page":"Daf","title":"Daf","text":"","category":"section"},{"location":"index.html","page":"Daf","title":"Daf","text":"Daf.Daf","category":"page"},{"location":"index.html#Daf.Daf","page":"Daf","title":"Daf.Daf","text":"The Daf.jl package provides a uniform generic interface for accessing 1D and 2D data arranged along some set of axes. This is a much-needed generalization of the AnnData functionality. The key features are:\n\nThe data model is based on (1) some axes with named entries, (2) vector data indexed by a single axis, (3) matrix data indexed by a pair of axes, and also (4) scalar data (anything not tied to some axis).\nThere is explicit control over 2D data layout (row or column major), and support for both dense and sparse matrices, both of which are crucial for performance.\nA simple query language makes it easy to access the data, providing features such as slicing, aggregation, and filtering.\nSupport both in-memory and persistent data storage of \"any\" format (given an adapter implementation).\nOut of the box, allow storing the data in memory, in AnnData objects (e.g., using h5ad files), directly inside HDF5 files (e.g., using h5df files), or as a collection of simple memory-mapped files in a directory (which works nicely with tools like make for automating computation pipelines).\n\nThe top-level Daf module re-exports all(most) everything from the sub-modules, so you can directly access any exported symbol by using Daf (or import Daf: MemoryStorage), instead of having to import or use qualified names (such as Daf.Storage.MemoryStorage).\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"Daf","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Daf","title":"Daf","text":"","category":"page"},{"location":"adapters.html#Adapters","page":"Adapters","title":"Adapters","text":"","category":"section"},{"location":"adapters.html","page":"Adapters","title":"Adapters","text":"Daf.Adapters\nDaf.Adapters.adapter","category":"page"},{"location":"adapters.html#Daf.Adapters","page":"Adapters","title":"Daf.Adapters","text":"Adapt daf data to a @computation.\n\n\n\n\n\n","category":"module"},{"location":"adapters.html#Daf.Adapters.adapter","page":"Adapters","title":"Daf.Adapters.adapter","text":"adapter(\n    computation::Function,\n    name::AbstractString,\n    view::Union{DafView, ReadOnlyView},\n    [capture=MemoryDaf,\n    scalars::AbstractVector{Pair{String, Union{String, Nothing}}} = [],\n    axes::AbstractVector{Pair{String, Union{String, Nothing}}} = [],\n    vectors::AbstractVector{Pair{Tuple{String, String}, Union{String, Nothing}}} = []],\n    matrices::AbstractVector{Pair{Tuple{String, String, String}, Union{String, Nothing}}} = [],\n    relayout::Bool = true,\n    overwrite::Bool = false]\n)::Any\n\nInvoke a computation on a view data set and return the result; copy a viewer of the updated data set into the base daf data of the view.\n\nIf you have some daf data you wish to run a computation on, you need to deal with name mismatches. That is, the names of the input and output data properties of the computation may be different from these used in your data. In addition, you might be interested only in a subset of the computed data properties, to avoiding polluting your data set with irrelevant properties.\n\nTo address these issues, the common idiom for applying computations to daf data is to use the adapter as follows:\n\nCreate a (read-only) view of your data which presents the data properties under the names expected by the computation, using viewer. If the computation was annotated by @computation, then its Contract will be explicitly documented so you will know exactly what to provide.\nPass this view to adapter, which will invoke the computation with a (writable) adapted version of the data (created using chain_writer and a new DafWriter to capture the output, by default, [MemoryDaf]@(ref)).\nOnce the computation is done, create a new view of the output, which presents the subset of the output data properties you are interested in, with the names you would like to store them as. Again, if the computation was annotated by @computation, then its Contract will be explicitly documented so you will know exactly what to expect.\nCopy this output view data into the base daf data of the view (using copy_all!, relayout (default: true) and overwrite (default: false).\n\nThat is, the code would look something like this:\n\ndaf = ... # Some input `daf` data we wish to compute on.\n\n# Here `daf` contains the inputs for the computation, but possibly\n# under a different name.\n\nresult = adapter(\n    \"example\",      # A name to use to generate the temporary `daf` data names.\n    view(daf; ...), # How to view the input in the way expected by the computation.\n    ...,            # How and what to view the output for copying back into `daf`.\n) do adapted        # The writable adapted data we can pass to the computation.\n    computation(adapted, ...)  # Actually do the computation.\n    return ...                 # An additional result outside `daf`.\nend\n\n# Here `daf` will contain the specific renamed outputs specified in `adapter`,\n# and you can also access the additional non-`daf` data `result`.\n\nThis idiom allows @computation functions to use clear generic names for their inputs and outputs, and still apply them to arbitrary data sets using more specific names. For example, one can invoke the same computation with different parameter values, and store the different results in the same data set under different names. Or, one can pre-process the inputs of the computation, storing the result under a different name, and still be able to apply the computation to these modified inputs.\n\n\n\n\n\n","category":"function"},{"location":"adapters.html#Index","page":"Adapters","title":"Index","text":"","category":"section"},{"location":"adapters.html","page":"Adapters","title":"Adapters","text":"Pages = [\"adapter.md\"]","category":"page"}]
}
