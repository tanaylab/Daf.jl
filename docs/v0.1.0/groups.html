<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Groups · Daf.jl v0.1.0</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="Daf.jl v0.1.0 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Daf.jl v0.1.0</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Daf</a></li><li><a class="tocitem" href="data.html">Data</a></li><li><a class="tocitem" href="read_only.html">Read-only</a></li><li><a class="tocitem" href="views.html">Views</a></li><li><a class="tocitem" href="chains.html">Chains</a></li><li><a class="tocitem" href="computations.html">Computations</a></li><li class="is-active"><a class="tocitem" href="groups.html">Groups</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="copies.html">Copies</a></li><li><a class="tocitem" href="adapters.html">Adapters</a></li><li><a class="tocitem" href="contracts.html">Contracts</a></li><li><a class="tocitem" href="formats.html">Formats</a></li><li><a class="tocitem" href="memory_format.html">Memory Format</a></li><li><a class="tocitem" href="data_queries.html">Data Queries</a></li><li><a class="tocitem" href="parse_queries.html">Queries</a></li><li><a class="tocitem" href="registry.html">Operations registry</a></li><li><a class="tocitem" href="operations.html">Query operations</a></li><li><a class="tocitem" href="storage_types.html">Storage types</a></li><li><a class="tocitem" href="matrix_layouts.html">Matrix layouts</a></li><li><a class="tocitem" href="oprec.html">Operator precedence parser</a></li><li><a class="tocitem" href="messages.html">Messages</a></li><li><a class="tocitem" href="example_data.html">Example data</a></li><li><a class="tocitem" href="todo.html">TODO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="groups.html">Groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="groups.html">Groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tanaylab/Daf.jl/blob/main/src/groups.md?plain=1#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Groups"><a class="docs-heading-anchor" href="#Groups">Groups</a><a id="Groups-1"></a><a class="docs-heading-anchor-permalink" href="#Groups" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Daf.Groups" href="#Daf.Groups"><code>Daf.Groups</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A common data pattern is for entries of one axis to be grouped together. When this happens, we can associate with each entry a data property of the group, or we can aggregate a data property of the entries into a data property of the group. For example, if we group cells into types, we can obtain a cell color by looking up the color of the type of each cell; or if each cell has an age, we can compute the mean cell age of each type.</p><p>The following functions implement these lookup and aggregation operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/groups.jl?plain=1#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Groups.get_chained_vector" href="#Daf.Groups.get_chained_vector"><code>Daf.Groups.get_chained_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_chained_vector(
    daf::DafReader;
    axis::AbstractString,
    names::Vector[S],
    [default::Union{StorageScalar, UndefInitializer} = undef]
) -&gt; StorageVector where {S &lt;: AbstractString}</code></pre><p>Given an <code>axis</code> and a series of <code>names</code> properties, expect each property value to be a string, used to lookup its value in a property axis of the same name, until the last property that is actually returned. For example, if the <code>axis</code> is <code>cell</code> and the <code>names</code> are <code>[&quot;batch&quot;, &quot;donor&quot;, &quot;sex&quot;]</code>, then fetch the sex of the donor of the batch of each cell.</p><p>The group axis is assumed to have the same name as the named property (e.g., there would be <code>batch</code> and <code>donor</code> axes). It is also possible to have the property name begin with the axis name followed by a <code>.suffix</code>, for example, fetching <code>[&quot;type.manual&quot;, &quot;color&quot;]</code> will fetch the <code>color</code> from the <code>type</code> axis, based on the value of the <code>type.manual</code> of each cell.</p><p>If, at any place along the chain, the group property value is the empty string, then <code>default</code> must be specified, and will be used for the final result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/groups.jl?plain=1#LL24-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Groups.aggregate_group_vector" href="#Daf.Groups.aggregate_group_vector"><code>Daf.Groups.aggregate_group_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function aggregate_group_vector(
    aggregate::Function,
    daf::DafReader;
    axis::AbstractString,
    name::AbstractString,
    group::AbstractString,
    group_axis::Union{AbstractString, Nothing} = nothing,
    default::Union{StorageScalar, UndefInitializer} = undef,
)::NamedArray</code></pre><p>Given an <code>axis</code> of the <code>daf</code> data (e.g., cell), a <code>name</code> vector property of this axis (e.g., age) and a <code>group</code> vector property of this axis (e.g., type), whose value is the name of an entry of a group axis, then return a vector assigning a value for each entry of the group axis, which is the <code>aggregate</code> of the values of all the original axis entries grouped into that entry (e.g., the mean age of the cells in each type).</p><p>By default, the <code>group_axis</code> is assumed to have the same name as the <code>group</code> property (e.g., there would be a type property per cell, and a type axis). It is possible to override this by specifying an explicit <code>group_axis</code> if the actual name is different.</p><p>The <code>group</code> property must have a string element type. An empty string means that the entry belongs to no group (e.g., we don&#39;t have a type assignment for some cell), so its value will not be aggregated into any group. In addition, a group may be empty (e.g., no cell is assigned to some type). In this case, <code>default</code> must be specified, and is used for the empty groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/groups.jl?plain=1#LL66-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Groups.count_groups_matrix" href="#Daf.Groups.count_groups_matrix"><code>Daf.Groups.count_groups_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function count_groups_matrix(
    daf::DafReader,
    axis::AbstractString,
    rows_names::Vector{R},
    columns_names::Vector{C};
    type::Type = UInt32,
    rows_default::Union{StorageScalar, Nothing},
    columns_default::Union{StorageScalar, Nothing},
)::NamedMatrix</code></pre><p>Given an <code>axis</code> of the <code>daf</code> data (e.g., cell), fetch two chained vector properties for it using <a href="groups.html#Daf.Groups.get_chained_vector"><code>get_chained_vector</code></a>, and generate a matrix where each entry is the number of instances which have each specific combination of the values. For example, if <code>axis</code> is <code>cell</code>, <code>rows_names</code> is <code>[&quot;batch&quot;, &quot;age&quot;]</code>, and <code>columns_names</code> is <code>[&quot;type&quot;, &quot;color&quot;]</code>, then the matrix will have the different ages as rows, different colors as columns, and each entry will count the number of cells with a specific age and a specific color.</p><p>If there exists an axis with the same name as the final row and/or column name, it is used to determine the set of valid values and their order. Otherwise, the entries are sorted in ascending order.</p><p>By default, the data type of the matrix is <code>UInt32</code>, which is a reasonable trade-off between expressiveness (up to 4G) and size (only 4 bytes per entry). You can override this using the <code>type</code> parameter.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The typically the chained value type is a string; in this case, entries with an empty string values (ungrouped entries) are not counted. However, the values can also be numeric. In either case, it is expected that the set of actually present values will be small, otherwise the resulting matrix will be very large.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/groups.jl?plain=1#LL139-L167">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="groups.html#Daf.Groups"><code>Daf.Groups</code></a></li><li><a href="groups.html#Daf.Groups.aggregate_group_vector"><code>Daf.Groups.aggregate_group_vector</code></a></li><li><a href="groups.html#Daf.Groups.count_groups_matrix"><code>Daf.Groups.count_groups_matrix</code></a></li><li><a href="groups.html#Daf.Groups.get_chained_vector"><code>Daf.Groups.get_chained_vector</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="computations.html">« Computations</a><a class="docs-footer-nextpage" href="copies.html">Copies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
