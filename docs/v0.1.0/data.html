<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data · Daf.jl v0.1.0</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="Daf.jl v0.1.0 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Daf.jl v0.1.0</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Daf</a></li><li class="is-active"><a class="tocitem" href="data.html">Data</a><ul class="internal"><li><a class="tocitem" href="#Read-API"><span>Read API</span></a></li><li><a class="tocitem" href="#Data-axes"><span>Data axes</span></a></li><li><a class="tocitem" href="#Write-API"><span>Write API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="copies.html">Copies</a></li><li><a class="tocitem" href="read_only.html">Read-only</a></li><li><a class="tocitem" href="views.html">Views</a></li><li><a class="tocitem" href="chains.html">Chains</a></li><li><a class="tocitem" href="computations.html">Computations</a></li><li><a class="tocitem" href="contracts.html">Contracts</a></li><li><a class="tocitem" href="formats.html">Formats</a></li><li><a class="tocitem" href="memory_format.html">Memory Format</a></li><li><a class="tocitem" href="queries.html">Queries</a></li><li><a class="tocitem" href="registry.html">Operations registry</a></li><li><a class="tocitem" href="operations.html">Query operations</a></li><li><a class="tocitem" href="storage_types.html">Storage types</a></li><li><a class="tocitem" href="matrix_layouts.html">Matrix layouts</a></li><li><a class="tocitem" href="oprec.html">Operator precedence parser</a></li><li><a class="tocitem" href="messages.html">Messages</a></li><li><a class="tocitem" href="example_data.html">Example data</a></li><li><a class="tocitem" href="todo.html">TODO</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="data.html">Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="data.html">Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.md?plain=1#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Daf.Data" href="#Daf.Data"><code>Daf.Data</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The <a href="formats.html#Daf.Formats.DafReader"><code>DafReader</code></a> and <a href="formats.html#Daf.Formats.DafWriter"><code>DafWriter</code></a> interfaces specify a high-level API for accessing <code>Daf</code> data. This API is implemented here, on top of the low-level <a href="formats.html#Daf.Formats.FormatReader"><code>FormatReader</code></a> and <a href="formats.html#Daf.Formats.FormatWriter"><code>FormatWriter</code></a> API.</p><p>Data properties are identified by a unique name given the axes they are based on. That is, there is a separate namespace for scalar properties, vector properties for each specific axis, and matrix properties for each <em>unordered</em> pair of axes.</p><p>For matrices, we keep careful track of their <a href="matrix_layouts.html#Daf.MatrixLayouts"><code>MatrixLayouts</code></a>. Returned matrices are always in column-major layout, using <a href="matrix_layouts.html#Daf.MatrixLayouts.relayout!"><code>relayout!</code></a> if necessary. As this is an expensive operation, we&#39;ll cache the result in memory. Similarly, we cache the results of applying a query to the data. We allow clearing the cache to reduce memory usage, if necessary.</p><p>The data API is the high-level API intended to be used from outside the package, and is therefore re-exported from the top-level <code>Daf</code> namespace. It provides additional functionality on top of the low-level <a href="formats.html#Daf.Formats.FormatReader"><code>FormatReader</code></a> and <a href="formats.html#Daf.Formats.FormatWriter"><code>FormatWriter</code></a> implementations, accepting more general data types, automatically dealing with <a href="matrix_layouts.html#Daf.MatrixLayouts.relayout!"><code>relayout!</code></a> when needed, and even providing a language for <a href="queries.html#Daf.Queries"><code>Queries</code></a> for flexible extraction of data from the container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1-L18">source</a></section></article><h2 id="Read-API"><a class="docs-heading-anchor" href="#Read-API">Read API</a><a id="Read-API-1"></a><a class="docs-heading-anchor-permalink" href="#Read-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.description" href="#Daf.Data.description"><code>Daf.Data.description</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">description(daf::DafReader[; deep::Bool = false])::AbstractString</code></pre><p>Return a (multi-line) description of the contents of <code>daf</code>. This tries to hit a sweet spot between usefulness and terseness. If <code>deep</code>, also describes any data set nested inside this one (if any).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1272-L1277">source</a></section></article><h3 id="Queries"><a class="docs-heading-anchor" href="#Queries">Queries</a><a id="Queries-1"></a><a class="docs-heading-anchor-permalink" href="#Queries" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.scalar_query" href="#Daf.Data.scalar_query"><code>Daf.Data.scalar_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_query(daf::DafReader, query::AbstractString)::Union{StorageScalar, Nothing}</code></pre><p>Query <code>daf</code> for some scalar results. See <a href="queries.html#Daf.Queries.ScalarQuery"><code>ScalarQuery</code></a> for the possible queries that return scalar results.</p><p>The query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can <a href="data.html#Daf.Data.empty_cache!"><code>empty_cache!</code></a> to release it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1844-L1851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.vector_query" href="#Daf.Data.vector_query"><code>Daf.Data.vector_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_query(daf::DafReader, query::AbstractString)::Union{NamedVector, Nothing}</code></pre><p>Query <code>daf</code> for some vector results. See <a href="queries.html#Daf.Queries.VectorQuery"><code>VectorQuery</code></a> for the possible queries that return vector results. The names of the results are the names of the axis entries. This is especially useful when the query applies a mask to the axis. Will return <code>nothing</code> if any of the masks is empty.</p><p>The query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can <a href="data.html#Daf.Data.empty_cache!"><code>empty_cache!</code></a> to release it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1749-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.matrix_query" href="#Daf.Data.matrix_query"><code>Daf.Data.matrix_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_query(daf::DafReader, query::AbstractString)::Union{NamedMatrix, Nothing}</code></pre><p>Query <code>daf</code> for some matrix results. See <a href="queries.html#Daf.Queries.MatrixQuery"><code>MatrixQuery</code></a> for the possible queries that return matrix results. The names of the axes of the result are the names of the axis entries. This is especially useful when the query applies masks to the axes. Will return <code>nothing</code> if any of the masks is empty.</p><p>The query result is cached in memory to speed up repeated queries. For computed queries (e.g., results of element-wise operations) this may lock up very large amounts of memory; you can <a href="data.html#Daf.Data.empty_cache!"><code>empty_cache!</code></a> to release it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1394-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.empty_cache!" href="#Daf.Data.empty_cache!"><code>Daf.Data.empty_cache!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_cache!(daf::DafReader)::Nothing</code></pre><p>Empty the cached computed results. This includes computed query results, as well as any relayout matrices that couldn&#39;t be stored in the <code>daf</code> storage itself.</p><p>This might be needed if caching consumes too much memory. To see what (if anything) is cached, look at the results of <a href="data.html#Daf.Data.description"><code>description</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL2021-L2029">source</a></section></article><h3 id="Scalar-properties"><a class="docs-heading-anchor" href="#Scalar-properties">Scalar properties</a><a id="Scalar-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.has_scalar" href="#Daf.Data.has_scalar"><code>Daf.Data.has_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_scalar(daf::DafReader, name::AbstractString)::Bool</code></pre><p>Check whether a scalar property with some <code>name</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.get_scalar" href="#Daf.Data.get_scalar"><code>Daf.Data.get_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_scalar(
    daf::DafReader,
    name::AbstractString;
    [default::Union{StorageScalar, Nothing, Missing} = nothing]
)::Union{StorageScalar, Missing}</code></pre><p>Get the value of a scalar property with some <code>name</code> in <code>daf</code>.</p><p>If <code>default</code> is <code>nothing</code> (the default), this first verifies the <code>name</code> scalar property exists in <code>daf</code>. Otherwise <code>default</code> will be returned of it does not exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL160-L171">source</a></section></article><h2 id="Data-axes"><a class="docs-heading-anchor" href="#Data-axes">Data axes</a><a id="Data-axes-1"></a><a class="docs-heading-anchor-permalink" href="#Data-axes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.has_axis" href="#Daf.Data.has_axis"><code>Daf.Data.has_axis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_axis(daf::DafReader, axis::AbstractString)::Bool</code></pre><p>Check whether some <code>axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.axis_names" href="#Daf.Data.axis_names"><code>Daf.Data.axis_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axis_names(daf::DafReader)::AbstractSet{String}</code></pre><p>The names of the axes of <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.get_axis" href="#Daf.Data.get_axis"><code>Daf.Data.get_axis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_axis(
    daf::DafReader,
    axis::AbstractString
    [; default::Union{Nothing, Missing} = nothing]
)::Union{AbstractVector{String}, Missing}</code></pre><p>The unique names of the entries of some <code>axis</code> of <code>daf</code>. This is similar to doing <a href="data.html#Daf.Data.get_vector"><code>get_vector</code></a> for the special <code>name</code> property, except that it returns a simple vector of strings instead of a <code>NamedVector</code>.</p><p>If <code>default</code> is <code>missing</code>, it is returned if the <code>axis</code> does not exist. Otherwise (the default), this verifies the <code>axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL285-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.axis_length" href="#Daf.Data.axis_length"><code>Daf.Data.axis_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axis_length(daf::DafReader, axis::AbstractString)::Int64</code></pre><p>The number of entries along the <code>axis</code> in <code>daf</code>.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL314-L320">source</a></section></article><h3 id="Vector-properties"><a class="docs-heading-anchor" href="#Vector-properties">Vector properties</a><a id="Vector-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.has_vector" href="#Daf.Data.has_vector"><code>Daf.Data.has_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_vector(daf::DafReader, axis::AbstractString, name::AbstractString)::Bool</code></pre><p>Check whether a vector property with some <code>name</code> exists for the <code>axis</code> in <code>daf</code>. This is always true for the special <code>name</code> property.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL340-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.vector_names" href="#Daf.Data.vector_names"><code>Daf.Data.vector_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_names(daf::DafReader, axis::AbstractString)::Set{String}</code></pre><p>The names of the vector properties for the <code>axis</code> in <code>daf</code>, <strong>not</strong> including the special <code>name</code> property.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL537-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.get_vector" href="#Daf.Data.get_vector"><code>Daf.Data.get_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_vector(
    daf::DafReader,
    axis::AbstractString,
    name::AbstractString;
    [default::Union{StorageScalar, StorageVector, Nothing, Missing} = nothing]
)::Union{NamedVector, Missing}</code></pre><p>Get the vector property with some <code>name</code> for some <code>axis</code> in <code>daf</code>. The names of the result are the names of the vector entries (same as returned by <a href="data.html#Daf.Data.get_axis"><code>get_axis</code></a>). The special property <code>name</code> returns an array whose values are also the (read-only) names of the entries of the axis.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code>. If <code>default</code> is <code>nothing</code> (the default), this first verifies the <code>name</code> vector exists in <code>daf</code>. Otherwise, if <code>default</code> is <code>missing</code>, it will be returned. If it is a <code>StorageVector</code>, it has to be of the same size as the <code>axis</code>, and is returned. If it is a <a href="storage_types.html#Daf.StorageTypes.StorageScalar"><code>StorageScalar</code></a>. Otherwise, a new <code>Vector</code> is created of the correct size containing the <code>default</code>, and is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL549-L565">source</a></section></article><h3 id="Matrix-properties"><a class="docs-heading-anchor" href="#Matrix-properties">Matrix properties</a><a id="Matrix-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.has_matrix" href="#Daf.Data.has_matrix"><code>Daf.Data.has_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_matrix(
    daf::DafReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
    [relayout::Bool = true]
)::Bool</code></pre><p>Check whether a matrix property with some <code>name</code> exists for the <code>rows_axis</code> and the <code>columns_axis</code> in <code>daf</code>. Since this is Julia, this means a column-major matrix. A daf may contain two copies of the same data, in which case it would report the matrix under both axis orders.</p><p>If <code>relayout</code> (the default), this will also check whether the data exists in the other layout (that is, with flipped axes).</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL634-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.matrix_names" href="#Daf.Data.matrix_names"><code>Daf.Data.matrix_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_names(
    daf::DafReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString;
    [relayout::Bool = true]
)::Set{String}</code></pre><p>The names of the matrix properties for the <code>rows_axis</code> and <code>columns_axis</code> in <code>daf</code>.</p><p>If <code>relayout</code> (default), then this will include the names of matrices that exist in the other layout (that is, with flipped axes).</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL949-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.get_matrix" href="#Daf.Data.get_matrix"><code>Daf.Data.get_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_matrix(
    daf::DafReader,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
    [default::Union{StorageScalar, StorageMatrix, Nothing, Missing} = nothing,
    relayout::Bool = true]
)::Union{NamedMatrix, Missing}</code></pre><p>Get the column-major matrix property with some <code>name</code> for some <code>rows_axis</code> and <code>columns_axis</code> in <code>daf</code>. The names of the result axes are the names of the relevant axes entries (same as returned by <a href="data.html#Daf.Data.get_axis"><code>get_axis</code></a>).</p><p>If <code>relayout</code> (the default), then if the matrix is only stored in the other memory layout (that is, with flipped axes), then automatically call <a href="matrix_layouts.html#Daf.MatrixLayouts.relayout!"><code>relayout!</code></a> to compute the result. If <code>daf isa DafWriter</code>, then store the result for future use; otherwise, just cache it in-memory (similar to a query result). This may lock up very large amounts of memory; you can <a href="data.html#Daf.Data.empty_cache!"><code>empty_cache!</code></a> to release it.</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>. If <code>default</code> is <code>nothing</code> (the default), this first verifies the <code>name</code> matrix exists in <code>daf</code>. Otherwise, if <code>default</code> is <code>missing</code>, it is returned. if <code>default</code> is a <code>StorageMatrix</code>, it has to be of the same size as the <code>rows_axis</code> and <code>columns_axis</code>, and is returned. Otherwise, a new <code>Matrix</code> is created of the correct size containing the <code>default</code>, and is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL1024-L1046">source</a></section></article><h2 id="Write-API"><a class="docs-heading-anchor" href="#Write-API">Write API</a><a id="Write-API-1"></a><a class="docs-heading-anchor-permalink" href="#Write-API" title="Permalink"></a></h2><h3 id="Scalar-properties-2"><a class="docs-heading-anchor" href="#Scalar-properties-2">Scalar properties</a><a class="docs-heading-anchor-permalink" href="#Scalar-properties-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.set_scalar!" href="#Daf.Data.set_scalar!"><code>Daf.Data.set_scalar!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_scalar!(
    daf::DafWriter,
    name::AbstractString,
    value::StorageScalar;
    [overwrite::Bool = false]
)::Nothing</code></pre><p>Set the <code>value</code> of a scalar property with some <code>name</code> in <code>daf</code>.</p><p>If not <code>overwrite</code> (the default), this first verifies the <code>name</code> scalar property does not exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL97-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.delete_scalar!" href="#Daf.Data.delete_scalar!"><code>Daf.Data.delete_scalar!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_scalar!(
    daf::DafWriter,
    name::AbstractString;
    must_exist::Bool = true,
)::Nothing</code></pre><p>Delete a scalar property with some <code>name</code> from <code>daf</code>.</p><p>If <code>must_exist</code> (the default), this first verifies the <code>name</code> scalar property exists in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL122-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.scalar_names" href="#Daf.Data.scalar_names"><code>Daf.Data.scalar_names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar_names(daf::DafReader)::Set{String}</code></pre><p>The names of the scalar properties in <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL151-L155">source</a></section></article><h3 id="Data-axes-2"><a class="docs-heading-anchor" href="#Data-axes-2">Data axes</a><a class="docs-heading-anchor-permalink" href="#Data-axes-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.add_axis!" href="#Daf.Data.add_axis!"><code>Daf.Data.add_axis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axis!(
    daf::DafWriter,
    axis::AbstractString,
    entries::AbstractVector{String}
)::Nothing</code></pre><p>Add a new <code>axis</code> <code>daf</code>.</p><p>This first verifies the <code>axis</code> does not exist and that the <code>entries</code> are unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL211-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.delete_axis!" href="#Daf.Data.delete_axis!"><code>Daf.Data.delete_axis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_axis!(
    daf::DafWriter,
    axis::AbstractString;
    must_exist::Bool = true,
)::Nothing</code></pre><p>Delete an <code>axis</code> from the <code>daf</code>. This will also delete any vector or matrix properties that are based on this axis.</p><p>If <code>must_exist</code> (the default), this first verifies the <code>axis</code> exists in the <code>daf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL233-L243">source</a></section></article><h3 id="Vector-properties-2"><a class="docs-heading-anchor" href="#Vector-properties-2">Vector properties</a><a class="docs-heading-anchor-permalink" href="#Vector-properties-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.set_vector!" href="#Daf.Data.set_vector!"><code>Daf.Data.set_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_vector!(
    daf::DafWriter,
    axis::AbstractString,
    name::AbstractString,
    vector::Union{StorageScalar, StorageVector};
    [overwrite::Bool = false]
)::Nothing</code></pre><p>Set a vector property with some <code>name</code> for some <code>axis</code> in <code>daf</code>.</p><p>If the <code>vector</code> specified is actually a <a href="storage_types.html#Daf.StorageTypes.StorageScalar"><code>StorageScalar</code></a>, the stored vector is filled with this value.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code>, that the property name isn&#39;t <code>name</code>, and that the <code>vector</code> has the appropriate length. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> vector does not exist for the <code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL353-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.delete_vector!" href="#Daf.Data.delete_vector!"><code>Daf.Data.delete_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_vector!(
    daf::DafWriter,
    axis::AbstractString,
    name::AbstractString;
    must_exist::Bool = true,
)::Nothing</code></pre><p>Delete a vector property with some <code>name</code> for some <code>axis</code> from <code>daf</code>.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code> and that the property name isn&#39;t <code>name</code>. If <code>must_exist</code> (the default), this also verifies the <code>name</code> vector exists for the <code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL502-L514">source</a></section></article><h3 id="Matrix-properties-2"><a class="docs-heading-anchor" href="#Matrix-properties-2">Matrix properties</a><a class="docs-heading-anchor-permalink" href="#Matrix-properties-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.set_matrix!" href="#Daf.Data.set_matrix!"><code>Daf.Data.set_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_matrix!(
    daf::DafWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    matrix::StorageMatrix;
    [overwrite::Bool = false,
    relayout::Bool = true]
)::Nothing</code></pre><p>Set the matrix property with some <code>name</code> for some <code>rows_axis</code> and <code>columns_axis</code> in <code>daf</code>. Since this is Julia, this should be a column-major <code>matrix</code>.</p><p>If the <code>matrix</code> specified is actually a <a href="storage_types.html#Daf.StorageTypes.StorageScalar"><code>StorageScalar</code></a>, the stored matrix is filled with this value.</p><p>If <code>relayout</code> (the default), this will also automatically <a href="matrix_layouts.html#Daf.MatrixLayouts.relayout!"><code>relayout!</code></a> the matrix and store the result, so the data would also be stored in row-major layout (that is, with the axes flipped), similarly to calling <a href="data.html#Daf.Data.relayout_matrix!"><code>relayout_matrix!</code></a>.</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>, that the <code>matrix</code> is column-major of the appropriate size. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> matrix does not exist for the <code>rows_axis</code> and <code>columns_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL665-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.relayout_matrix!" href="#Daf.Data.relayout_matrix!"><code>Daf.Data.relayout_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relayout_matrix!(
    daf::DafWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
    [overwrite::Bool = false]
)::Nothing</code></pre><p>Given a matrix property with some <code>name</code> exists (in column-major layout) in <code>daf</code> for the <code>rows_axis</code> and the <code>columns_axis</code>, then <a href="matrix_layouts.html#Daf.MatrixLayouts.relayout!"><code>relayout!</code></a> it and store the row-major result as well (that is, with flipped axes).</p><p>This is useful following calling <a href="data.html#Daf.Data.empty_dense_matrix!"><code>empty_dense_matrix!</code></a> or <a href="data.html#Daf.Data.empty_sparse_matrix!"><code>empty_sparse_matrix!</code></a> to ensure both layouts of the matrix are stored in <code>def</code>. When calling <a href="data.html#Daf.Data.set_matrix!"><code>set_matrix!</code></a>, it is simpler to just specify (the default) <code>relayout = true</code>.</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>, and that there is a <code>name</code> (column-major) matrix property for them. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> matrix does not exist for the <em>flipped</em> <code>rows_axis</code> and <code>columns_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL852-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.delete_matrix!" href="#Daf.Data.delete_matrix!"><code>Daf.Data.delete_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete_matrix!(
    daf::DafWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString;
    [must_exist::Bool = true,
    relayout::Bool = true]
)::Nothing</code></pre><p>Delete a matrix property with some <code>name</code> for some <code>rows_axis</code> and <code>columns_axis</code> from <code>daf</code>.</p><p>If <code>relayout</code> (the default), this will also delete the matrix in the other layout (that is, with flipped axes).</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>. If <code>must_exist</code> (the default), this also verifies the <code>name</code> matrix exists for the <code>rows_axis</code> and <code>columns_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL896-L912">source</a></section></article><h3 id="Creating-properties"><a class="docs-heading-anchor" href="#Creating-properties">Creating properties</a><a id="Creating-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.empty_dense_vector!" href="#Daf.Data.empty_dense_vector!"><code>Daf.Data.empty_dense_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_dense_vector!(
    fill::Function,
    daf::DafWriter,
    axis::AbstractString,
    name::AbstractString,
    eltype::Type{T};
    [overwrite::Bool = false]
)::Any where {T &lt;: Number}</code></pre><p>Create an empty dense vector property with some <code>name</code> for some <code>axis</code> in <code>daf</code>, pass it to <code>fill</code>, and return the result.</p><p>The returned vector will be uninitialized; the caller is expected to <code>fill</code> it with values. This saves creating a copy of the vector before setting it in the data, which makes a huge difference when creating vectors on disk (using memory mapping). For this reason, this does not work for strings, as they do not have a fixed size.</p><p>This first verifies the <code>axis</code> exists in <code>daf</code> and that the property name isn&#39;t <code>name</code>. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> vector does not exist for the <code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL400-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.empty_sparse_vector!" href="#Daf.Data.empty_sparse_vector!"><code>Daf.Data.empty_sparse_vector!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_sparse_vector!(
    fill::Function,
    daf::DafWriter,
    axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
    nnz::Integer,
    indtype::Type{I};
    [overwrite::Bool = false]
)::Any where {T &lt;: Number, I &lt;: Integer}</code></pre><p>Create an empty sparse vector property with some <code>name</code> for some <code>axis</code> in <code>daf</code>, pass it to <code>fill</code> and return the result.</p><p>The returned vector will be uninitialized; the caller is expected to <code>fill</code> it with values. This means manually filling the <code>nzind</code> and <code>nzval</code> vectors. Specifying the <code>nnz</code> makes their sizes known in advance, to allow pre-allocating disk data. For this reason, this does not work for strings, as they do not have a fixed size.</p><p>This severely restricts the usefulness of this function, because typically <code>nnz</code> is only know after fully computing the matrix. Still, in some cases a large sparse vector is created by concatenating several smaller ones; this function allows doing so directly into the data vector, avoiding a copy in case of memory-mapped disk formats.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is the caller&#39;s responsibility to fill the three vectors with valid data. Specifically, you must ensure:</p><ul><li><code>nzind[1] == 1</code></li><li><code>nzind[i] &lt;= nzind[i + 1]</code></li><li><code>nzind[end] == nnz</code></li></ul></div></div><p>This first verifies the <code>axis</code> exists in <code>daf</code> and that the property name isn&#39;t <code>name</code>. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> vector does not exist for the <code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL441-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.empty_dense_matrix!" href="#Daf.Data.empty_dense_matrix!"><code>Daf.Data.empty_dense_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_dense_matrix!(
    fill::Function,
    daf::DafWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    eltype::Type{T};
    [overwrite::Bool = false]
)::Any where {T &lt;: Number}</code></pre><p>Create an empty dense matrix property with some <code>name</code> for some <code>rows_axis</code> and <code>columns_axis</code> in <code>daf</code>, pass it to <code>fill</code>, and return the result. Since this is Julia, this will be a column-major <code>matrix</code>.</p><p>The returned matrix will be uninitialized; the caller is expected to <code>fill</code> it with values. This saves creating a copy of the matrix before setting it in <code>daf</code>, which makes a huge difference when creating matrices on disk (using memory mapping). For this reason, this does not work for strings, as they do not have a fixed size.</p><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>, that the <code>matrix</code> is column-major of the appropriate size. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> matrix does not exist for the <code>rows_axis</code> and <code>columns_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL734-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Daf.Data.empty_sparse_matrix!" href="#Daf.Data.empty_sparse_matrix!"><code>Daf.Data.empty_sparse_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_sparse_matrix!(
    fill::Function,
    daf::DafWriter,
    rows_axis::AbstractString,
    columns_axis::AbstractString,
    name::AbstractString,
    eltype::Type{T},
    nnz::Integer,
    intdype::Type{I};
    [overwrite::Bool = false]
)::Any where {T &lt;: Number, I &lt;: Integer}</code></pre><p>Create an empty sparse matrix property with some <code>name</code> for some <code>rows_axis</code> and <code>columns_axis</code> in <code>daf</code>, pass it to <code>fill</code>, and return the result.</p><p>The returned matrix will be uninitialized; the caller is expected to <code>fill</code> it with values. This means manually filling the <code>colptr</code>, <code>rowval</code> and <code>nzval</code> vectors. Specifying the <code>nnz</code> makes their sizes known in advance, to allow pre-allocating disk space. For this reason, this does not work for strings, as they do not have a fixed size.</p><p>This severely restricts the usefulness of this function, because typically <code>nnz</code> is only know after fully computing the matrix. Still, in some cases a large sparse matrix is created by concatenating several smaller ones; this function allows doing so directly into the data, avoiding a copy in case of memory-mapped disk formats.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>https://science.slashdot.org/story/23/08/12/1942234/common-alzheimers-disease-gene-may-have-helped-our-ancestors-have-more-kids It is the caller&#39;s responsibility to fill the three vectors with valid data. Specifically, you must ensure:</p><pre><code class="nohighlight hljs">  - `colptr[1] == 1`
  - `colptr[end] == nnz + 1`
  - `colptr[i] &lt;= colptr[i + 1]`
  - for all `j`, for all `i` such that `colptr[j] &lt;= i` and `i + 1 &lt; colptr[j + 1]`, `1 &lt;= rowptr[i] &lt; rowptr[i + 1] &lt;= nrows`</code></pre><p>This first verifies the <code>rows_axis</code> and <code>columns_axis</code> exist in <code>daf</code>. If not <code>overwrite</code> (the default), this also verifies the <code>name</code> matrix does not exist for the <code>rows_axis</code> and <code>columns_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tanaylab/Daf.jl/blob/main/src/data.jl?plain=1#LL786-L823">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="data.html#Daf.Data"><code>Daf.Data</code></a></li><li><a href="data.html#Daf.Data.add_axis!"><code>Daf.Data.add_axis!</code></a></li><li><a href="data.html#Daf.Data.axis_length"><code>Daf.Data.axis_length</code></a></li><li><a href="data.html#Daf.Data.axis_names"><code>Daf.Data.axis_names</code></a></li><li><a href="data.html#Daf.Data.delete_axis!"><code>Daf.Data.delete_axis!</code></a></li><li><a href="data.html#Daf.Data.delete_matrix!"><code>Daf.Data.delete_matrix!</code></a></li><li><a href="data.html#Daf.Data.delete_scalar!"><code>Daf.Data.delete_scalar!</code></a></li><li><a href="data.html#Daf.Data.delete_vector!"><code>Daf.Data.delete_vector!</code></a></li><li><a href="data.html#Daf.Data.description"><code>Daf.Data.description</code></a></li><li><a href="data.html#Daf.Data.empty_cache!"><code>Daf.Data.empty_cache!</code></a></li><li><a href="data.html#Daf.Data.empty_dense_matrix!"><code>Daf.Data.empty_dense_matrix!</code></a></li><li><a href="data.html#Daf.Data.empty_dense_vector!"><code>Daf.Data.empty_dense_vector!</code></a></li><li><a href="data.html#Daf.Data.empty_sparse_matrix!"><code>Daf.Data.empty_sparse_matrix!</code></a></li><li><a href="data.html#Daf.Data.empty_sparse_vector!"><code>Daf.Data.empty_sparse_vector!</code></a></li><li><a href="data.html#Daf.Data.get_axis"><code>Daf.Data.get_axis</code></a></li><li><a href="data.html#Daf.Data.get_matrix"><code>Daf.Data.get_matrix</code></a></li><li><a href="data.html#Daf.Data.get_scalar"><code>Daf.Data.get_scalar</code></a></li><li><a href="data.html#Daf.Data.get_vector"><code>Daf.Data.get_vector</code></a></li><li><a href="data.html#Daf.Data.has_axis"><code>Daf.Data.has_axis</code></a></li><li><a href="data.html#Daf.Data.has_matrix"><code>Daf.Data.has_matrix</code></a></li><li><a href="data.html#Daf.Data.has_scalar"><code>Daf.Data.has_scalar</code></a></li><li><a href="data.html#Daf.Data.has_vector"><code>Daf.Data.has_vector</code></a></li><li><a href="data.html#Daf.Data.matrix_names"><code>Daf.Data.matrix_names</code></a></li><li><a href="data.html#Daf.Data.matrix_query"><code>Daf.Data.matrix_query</code></a></li><li><a href="data.html#Daf.Data.relayout_matrix!"><code>Daf.Data.relayout_matrix!</code></a></li><li><a href="data.html#Daf.Data.scalar_names"><code>Daf.Data.scalar_names</code></a></li><li><a href="data.html#Daf.Data.scalar_query"><code>Daf.Data.scalar_query</code></a></li><li><a href="data.html#Daf.Data.set_matrix!"><code>Daf.Data.set_matrix!</code></a></li><li><a href="data.html#Daf.Data.set_scalar!"><code>Daf.Data.set_scalar!</code></a></li><li><a href="data.html#Daf.Data.set_vector!"><code>Daf.Data.set_vector!</code></a></li><li><a href="data.html#Daf.Data.vector_names"><code>Daf.Data.vector_names</code></a></li><li><a href="data.html#Daf.Data.vector_query"><code>Daf.Data.vector_query</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Daf</a><a class="docs-footer-nextpage" href="copies.html">Copies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
